// ***DO NOT EDIT THIS FILE - IT IS AUTOMATICALLY GENERATED BY CMAKE***

#include <osgEarth/Shaders>

namespace osgEarth { namespace Util
{
    Shaders::Shaders()
    {
        // Cascade Draping
        CascadeDraping = "CascadeDraping.glsl";
        _sources[CascadeDraping] = "#version $GLSL_VERSION_STR%EOL%%EOL%#pragma vp_name       Draping Vertex Shader%EOL%#pragma vp_entryPoint oe_Draping_VS%EOL%#pragma vp_location   vertex_view%EOL%%EOL%out vec4 oe_Draping_vertexView;%EOL%%EOL%void oe_Draping_VS(inout vec4 vertexView)%EOL%{%EOL%    oe_Draping_vertexView = vertexView;%EOL%}%EOL%%EOL%%EOL%[break]%EOL%%EOL%%EOL%#version $GLSL_VERSION_STR%EOL%%EOL%#pragma vp_name       Draping Fragment Shader%EOL%#pragma vp_entryPoint oe_Draping_FS%EOL%#pragma vp_location   fragment_coloring%EOL%#pragma vp_order      0.6%EOL%%EOL%#pragma import_defines(OE_IS_PICK_CAMERA)%EOL%#pragma import_defines(OE_DRAPING_MAX_CASCADES)%EOL%%EOL%uniform sampler2DArray oe_Draping_tex;%EOL%uniform mat4 oe_Draping_texMatrix[OE_DRAPING_MAX_CASCADES];%EOL%in vec4 oe_Draping_vertexView;%EOL%%EOL%void oe_Draping_FS(inout vec4 color)%EOL%{%EOL%    vec4 texel = vec4(0,0,0,0);%EOL%%EOL%    // the [3][3] slot will be zero if we have exceeded the current number of cascades%EOL%    for (int i=0; i<OE_DRAPING_MAX_CASCADES && oe_Draping_texMatrix[i][3][3] != 0; ++i)%EOL%    {%EOL%        vec4 coord = oe_Draping_texMatrix[i] * oe_Draping_vertexView;%EOL%        coord.xy /= coord.w;%EOL%        if (clamp(coord.xy, 0, 1) == coord.xy)%EOL%        {%EOL%            texel = texture(oe_Draping_tex, vec3(coord.xy, i));%EOL%            break;%EOL%        }%EOL%    }%EOL%%EOL%#ifdef OE_IS_PICK_CAMERA%EOL%    color = texel;%EOL%#else%EOL%    color = vec4( mix( color.rgb, texel.rgb, texel.a ), color.a);%EOL%#endif%EOL%}%EOL%%EOL%";

        // Clip Plane
        ClipPlane = "ClipPlane.glsl";
        _sources[ClipPlane] = "#version 330%EOL%#pragma vp_name       ClipPlane.glsl%EOL%#pragma vp_entryPoint oe_ClipPlane_VS%EOL%#pragma vp_location   vertex_view%EOL%#pragma vp_order      last%EOL%#pragma import_defines(OE_CLIPPLANE_NUM)%EOL%%EOL%// OSG built-in to transform from view to world%EOL%uniform mat4 osg_ViewMatrixInverse;%EOL%%EOL%// clipping plane%EOL%uniform vec4 oe_ClipPlane_plane;%EOL%%EOL%void oe_ClipPlane_VS(inout vec4 vertex_view)%EOL%{%EOL%#ifndef GL_ES%EOL%    gl_ClipDistance[OE_CLIPPLANE_NUM] = dot(osg_ViewMatrixInverse * vertex_view, oe_ClipPlane_plane);%EOL%#endif%EOL%}%EOL%%EOL%";

        // Depth Offset
        DepthOffset = "DepthOffset.glsl";
        _sources[DepthOffset] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_DepthOffset_vertex%EOL%#pragma vp_location   vertex_view%EOL%#pragma vp_order      0.8%EOL%%EOL%uniform vec4 oe_DepthOffset_params;%EOL%%EOL%void oe_DepthOffset_vertex(inout vec4 vertexView)%EOL%{%EOL%    // calculate range to target:%EOL%    float range = length(vertexView.xyz);%EOL%%EOL%    // extract params for clarity.%EOL%    float minBias = oe_DepthOffset_params[0];%EOL%    float maxBias = oe_DepthOffset_params[1];%EOL%    float minRange = oe_DepthOffset_params[2];%EOL%    float maxRange = oe_DepthOffset_params[3];%EOL%%EOL%    // calculate the depth offset bias for this range:%EOL%    float ratio = (clamp(range, minRange, maxRange)-minRange)/(maxRange-minRange);%EOL%    float bias = minBias + ratio * (maxBias-minBias);%EOL%%EOL%	// clamp the bias to 1/2 of the range of the vertex. We don't want to %EOL%    // pull the vertex TOO close to the camera and certainly not behind it.%EOL%    bias = min(bias, range*0.5);%EOL%    bias = min(bias, maxBias);%EOL%%EOL%    // pull the vertex towards the camera.%EOL%    vec3 pullVec = normalize(vertexView.xyz);%EOL%    vec3 simVert3 = vertexView.xyz - pullVec*bias;%EOL%    vertexView = vec4(simVert3, 1.0);%EOL%}%EOL%%EOL%";

        // Draping
        Draping = "Draping.glsl";
        _sources[Draping] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_overlay_vertex%EOL%#pragma vp_location   vertex_view%EOL%%EOL%uniform mat4 oe_overlay_texmatrix;%EOL%uniform float oe_overlay_rttLimitZ;%EOL%%EOL%out vec4 oe_overlay_texcoord;%EOL%%EOL%void oe_overlay_vertex(inout vec4 vertexVIEW)%EOL%{%EOL%    oe_overlay_texcoord = oe_overlay_texmatrix * vertexVIEW;%EOL%}%EOL%%EOL%%EOL%[break]%EOL%%EOL%%EOL%#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_overlay_fragment%EOL%#pragma vp_location   fragment_coloring%EOL%#pragma vp_order      0.6%EOL%%EOL%#pragma import_defines(OE_IS_PICK_CAMERA)%EOL%%EOL%uniform sampler2D oe_overlay_tex;%EOL%in vec4 oe_overlay_texcoord;%EOL%%EOL%void oe_overlay_fragment(inout vec4 color)%EOL%{%EOL%    vec4 texel = textureProj(oe_overlay_tex, oe_overlay_texcoord);%EOL%%EOL%#ifdef OE_IS_PICK_CAMERA%EOL%    color = texel;%EOL%#else%EOL%    color = vec4( mix( color.rgb, texel.rgb, texel.a ), color.a);%EOL%#endif%EOL%}%EOL%%EOL%";

        // GPU Clamping
        GPUClamping = "GPUClamping.glsl";
        _sources[GPUClamping] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_clamp_vertex%EOL%#pragma vp_location   vertex_view%EOL%#pragma vp_order      0.5%EOL%#pragma import_defines(OE_CLAMP_HAS_ATTRIBUTES)%EOL%#pragma import_defines(OE_IS_GEOCENTRIC)%EOL%#pragma include GPUClamping.lib.glsl%EOL%%EOL%#ifdef OE_CLAMP_HAS_ATTRIBUTES%EOL%in vec4 oe_clamp_attrs;     // vertex attribute%EOL%in float oe_clamp_height;   // vertex attribute%EOL%#endif%EOL%%EOL%out float oe_clamp_alpha;%EOL%%EOL%uniform float oe_clamp_altitudeOffset;%EOL%uniform float oe_clamp_horizonDistance2;%EOL%%EOL%void oe_clamp_clampViewSpaceVertex(inout vec4 vertexView)%EOL%{%EOL%#ifdef OE_CLAMP_HAS_ATTRIBUTES%EOL%    bool relativeToAnchor = (oe_clamp_attrs.a == 1.0); // 1.0 = ClampToAnchor%EOL%    float verticalOffset = oe_clamp_attrs.z;%EOL%    float clampHeight = oe_clamp_height;%EOL%%EOL%    // if we are using the anchor point, xform it into view space to prepare%EOL%    // for clamping. Force Z=0 for anchoring.%EOL%    vec4 pointToClamp = relativeToAnchor ?%EOL%        gl_ModelViewMatrix * vec4(oe_clamp_attrs.xy, 0.0, 1.0) :%EOL%        vertexView;%EOL%#else%EOL%    bool relativeToAnchor = false;%EOL%    float verticalOffset = 0.0;%EOL%    vec4 pointToClamp = vertexView;%EOL%    float clampHeight = 0.0;%EOL%#endif%EOL%%EOL%    // clamp the point and remember it's depth:%EOL%    vec4 clampedPoint;%EOL%    float depth;%EOL%    oe_getClampedViewVertex(pointToClamp, clampedPoint, depth);%EOL%%EOL%    float dh = verticalOffset + oe_clamp_altitudeOffset;%EOL%%EOL%    if (relativeToAnchor)%EOL%    {%EOL%        // if we are clamping relative to the anchor point, adjust the HAT based on the%EOL%        // distance from the anchor point to the terrain. Since distance() is unsigned,%EOL%        // we use the vector dot product to calculate whether to adjust up or down.%EOL%        float dist = distance(pointToClamp, clampedPoint);%EOL%        float dir = sign(dot(clampedPoint - pointToClamp, vertexView - pointToClamp));%EOL%        dh += (dist * dir);%EOL%    }%EOL%    else%EOL%    {%EOL%        // if we are clamping to the terrain, the vertex becomes the%EOL%        // clamped point%EOL%        vertexView.xyz = clampedPoint.xyz;%EOL%        dh += clampHeight;%EOL%    }%EOL%%EOL%    // calculate the up vector along which clamping will occur (in either direction)%EOL%    vec3 up;%EOL%    oe_getClampingUpVector(up);%EOL%    vertexView.xyz += up*dh;%EOL%%EOL%    // if the clamped depth value is near the far plane, suppress drawing%EOL%    // to avoid rendering anomalies.%EOL%    oe_clamp_alpha = 1.0 - step(0.9999, depth);%EOL%}%EOL%%EOL%void oe_clamp_vertex(inout vec4 vertexView)%EOL%{%EOL%    // check distance; alpha out if its beyone the horizon distance.%EOL%#ifdef OE_IS_GEOCENTRIC%EOL%    oe_clamp_alpha = clamp(oe_clamp_horizonDistance2 - (vertexView.z*vertexView.z), 0.0, 1.0);%EOL%#else%EOL%    oe_clamp_alpha = 1.0;%EOL%#endif%EOL%%EOL%    // if visible, calculate clamping.%EOL%    // note: no branch divergence in the vertex shader%EOL%    if ( oe_clamp_alpha > 0.0 )%EOL%    {%EOL%        oe_clamp_clampViewSpaceVertex(vertexView);%EOL%    }%EOL%}%EOL%%EOL%%EOL%[break]%EOL%%EOL%%EOL%#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_clamp_fragment%EOL%#pragma vp_location   fragment_coloring%EOL%%EOL%in float oe_clamp_alpha;%EOL%%EOL%void oe_clamp_fragment(inout vec4 color)%EOL%{%EOL%    // adjust the alpha component to %QUOTE%hide%QUOTE% geometry beyond the visible horizon.%EOL%    color.a *= oe_clamp_alpha;%EOL%}%EOL%%EOL%%EOL%";

        GPUClampingLib = "GPUClamping.lib.glsl";
        _sources[GPUClampingLib] = "// note: this is an include file%EOL%%EOL%// depth texture captures by the clamping technique%EOL%uniform sampler2D oe_clamp_depthTex;%EOL%%EOL%// matrix transforming from view space to depth-texture clip space%EOL%uniform mat4 oe_clamp_cameraView2depthClip;%EOL%%EOL%// matrix transform from depth-tecture clip space to view space%EOL%uniform mat4 oe_clamp_depthClip2cameraView;%EOL%%EOL%// Given a vertex in view space, clamp it to the %QUOTE%ground%QUOTE% as represented%EOL%// by an orthographic depth texture. Return the clamped vertex in view space,%EOL%// along with the associated depth value.%EOL%void oe_getClampedViewVertex(in vec4 vertView, out vec4 out_clampedVertView, out float out_depth)%EOL%{%EOL%    // transform the vertex into the depth texture's clip coordinates.%EOL%    vec4 vertDepthClip = oe_clamp_cameraView2depthClip * vertView;%EOL%%EOL%    // sample the depth map%EOL%    out_depth = textureProj( oe_clamp_depthTex, vertDepthClip ).r;%EOL%%EOL%    // now transform into depth-view space so we can apply the height-above-ground:%EOL%    vec4 clampedVertDepthClip = vec4(vertDepthClip.x, vertDepthClip.y, out_depth, 1.0);%EOL%%EOL%    // convert back into view space.%EOL%    out_clampedVertView = oe_clamp_depthClip2cameraView * clampedVertDepthClip;%EOL%}%EOL%%EOL%// Returns a vector indicating the %QUOTE%down%QUOTE% direction.%EOL%void oe_getClampingUpVector(out vec3 up)%EOL%{%EOL%    up = normalize(mat3(oe_clamp_depthClip2cameraView) * vec3(0,0,-1));%EOL%}%EOL%%EOL%";

        // DrawInstanced
        Instancing = "Instancing.glsl";
        _sources[Instancing] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#extension GL_EXT_gpu_shader4 : enable%EOL%#extension GL_ARB_draw_instanced: enable%EOL%%EOL%#pragma vp_entryPoint oe_di_setInstancePosition%EOL%#pragma vp_location   vertex_model%EOL%#pragma vp_order      0.0%EOL%%EOL%uniform samplerBuffer oe_di_postex_TBO;%EOL%%EOL%// Stage-global containing object ID%EOL%uint oe_index_objectid;%EOL%vec3 vp_Normal;%EOL%%EOL%void oe_di_setInstancePosition(inout vec4 VertexMODEL)%EOL%{ %EOL%    int index = 4 * gl_InstanceID;%EOL%%EOL%    vec4 m0 = texelFetch(oe_di_postex_TBO, index);%EOL%    vec4 m1 = texelFetch(oe_di_postex_TBO, index+1); %EOL%    vec4 m2 = texelFetch(oe_di_postex_TBO, index+2); %EOL%    vec4 m3 = texelFetch(oe_di_postex_TBO, index+3);%EOL%%EOL%    // decode the ObjectID from the last column:%EOL%    %EOL%    oe_index_objectid = uint(m3[0]) + (uint(m3[1]) << 8u) + (uint(m3[2]) << 16u) + (uint(m3[3]) << 24u);%EOL%    %EOL%    // rebuild positioning matrix and transform the vert. (Note, the matrix is actually%EOL%    // transposed so we have to reverse the multiplication order.)%EOL%    mat4 xform = mat4(m0, m1, m2, vec4(0,0,0,1));%EOL%%EOL%    VertexMODEL = VertexMODEL * xform;%EOL%%EOL%    // rotate the normal vector in the same manner.%EOL%    vp_Normal = vp_Normal * mat3(xform);%EOL%}%EOL%%EOL%%EOL%";

        // LineDrawable
        LineDrawable = "LineDrawable.glsl";
        _sources[LineDrawable] = "#version $GLSL_VERSION_STR%EOL%#pragma vp_name GPU Lines Screen Projected Model%EOL%#pragma vp_entryPoint oe_LineDrawable_VS_VIEW%EOL%#pragma vp_location vertex_view%EOL%#pragma vp_order last%EOL%%EOL%uniform vec2 oe_LineDrawable_limits;%EOL%flat out int oe_LineDrawable_draw;%EOL%%EOL%// Input attributes for adjacent points%EOL%in vec3 oe_LineDrawable_prev;%EOL%in vec3 oe_LineDrawable_next;%EOL%%EOL%// Shared stage globals%EOL%vec4 oe_LineDrawable_prevView;%EOL%vec4 oe_LineDrawable_nextView;%EOL%%EOL%void oe_LineDrawable_VS_VIEW(inout vec4 currView)%EOL%{%EOL%    oe_LineDrawable_draw = 1;%EOL%    int first = int(oe_LineDrawable_limits[0]);%EOL%    int last = int(oe_LineDrawable_limits[1]);%EOL%    if (first >= 0)%EOL%    {%EOL%        if (gl_VertexID < first || (last > 0 && gl_VertexID > last))%EOL%        {%EOL%            oe_LineDrawable_draw = 0;%EOL%        }%EOL%    }%EOL%%EOL%    // Compute the change in the view vertex so that we can apply the same%EOL%    // delta to the prev and next vectors. (An example would be if the verts%EOL%    // were GPU-clamped or otherwise permuted in another shader component.)%EOL%    vec4 originalView = gl_ModelViewMatrix * gl_Vertex;%EOL%    vec4 deltaView = currView - originalView;%EOL%%EOL%    // calculate prev/next points in post-transform view space:%EOL%    oe_LineDrawable_prevView = gl_ModelViewMatrix * vec4(oe_LineDrawable_prev,1) + deltaView;%EOL%    oe_LineDrawable_nextView = gl_ModelViewMatrix * vec4(oe_LineDrawable_next,1) + deltaView;%EOL%}%EOL%%EOL%%EOL%%EOL%[break]%EOL%%EOL%#version $GLSL_VERSION_STR%EOL%#pragma vp_name GPU Lines Screen Projected Clip%EOL%#pragma vp_entryPoint oe_LineDrawable_VS_CLIP%EOL%#pragma vp_location vertex_clip%EOL%#pragma import_defines(OE_LINE_SMOOTH)%EOL%%EOL%// Set by the InstallCameraUniform callback%EOL%uniform vec3 oe_Camera;%EOL%%EOL%// Set by GLUtils methods%EOL%uniform float oe_GL_LineWidth;%EOL%uniform int oe_GL_LineStipplePattern;%EOL%%EOL%// Input attributes for adjacent points%EOL%in vec3 oe_LineDrawable_prev;%EOL%in vec3 oe_LineDrawable_next;%EOL%%EOL%flat out int oe_LineDrawable_draw;%EOL%flat out vec2 oe_LineDrawable_rv;%EOL%%EOL%// Shared stage globals%EOL%vec4 oe_LineDrawable_prevView;%EOL%vec4 oe_LineDrawable_nextView;%EOL%%EOL%#ifdef OE_LINE_SMOOTH%EOL%out float oe_LineDrawable_lateral;%EOL%#else%EOL%float oe_LineDrawable_lateral;%EOL%#endif%EOL%%EOL%void oe_LineDrawable_VS_CLIP(inout vec4 currClip)%EOL%{%EOL%    if (oe_LineDrawable_draw == 0)%EOL%        return;%EOL%%EOL%    // Transform the prev and next points in clip space.%EOL%    vec4 prevClip = gl_ProjectionMatrix * oe_LineDrawable_prevView;%EOL%    vec4 nextClip = gl_ProjectionMatrix * oe_LineDrawable_nextView;%EOL%%EOL%    // Transform all points into pixel space%EOL%    vec2 prevPixel = ((prevClip.xy/prevClip.w)+1.0) * 0.5*oe_Camera.xy;%EOL%    vec2 currPixel = ((currClip.xy/currClip.w)+1.0) * 0.5*oe_Camera.xy;%EOL%    vec2 nextPixel = ((nextClip.xy/nextClip.w)+1.0) * 0.5*oe_Camera.xy;%EOL%%EOL%#ifdef OE_LINE_SMOOTH%EOL%    float thickness = floor(oe_GL_LineWidth + 1.0);%EOL%#else%EOL%    float thickness = max(0.5, floor(oe_GL_LineWidth));%EOL%#endif%EOL%%EOL%    float len = thickness;%EOL%    int code = (gl_VertexID+2) & 3; // gl_VertexID % 4%EOL%    bool isStart = code <= 1;%EOL%    bool isRight = code==0 || code==2;%EOL%%EOL%    oe_LineDrawable_lateral = isRight? -1.0 : 1.0;%EOL%%EOL%    vec2 dir = vec2(0.0);%EOL%%EOL%    // We will use this to calculate stippling data:%EOL%    vec2 stippleDir;%EOL%%EOL%    // The following vertex comparisons must be done in model %EOL%    // space because the equivalency gets mashed after projection.%EOL%%EOL%    // starting point uses (next - current)%EOL%    if (gl_Vertex.xyz == oe_LineDrawable_prev)%EOL%    {%EOL%        dir = normalize(nextPixel - currPixel);%EOL%        stippleDir = dir;%EOL%    }%EOL%    %EOL%    // ending point uses (current - previous)%EOL%    else if (gl_Vertex.xyz == oe_LineDrawable_next)%EOL%    {%EOL%        dir = normalize(currPixel - prevPixel);%EOL%        stippleDir = dir;%EOL%    }%EOL%%EOL%    else%EOL%    {%EOL%        vec2 dirIn  = normalize(currPixel - prevPixel);%EOL%        vec2 dirOut = normalize(nextPixel - currPixel);%EOL%%EOL%        if (dot(dirIn,dirOut) < -0.999999)%EOL%        {%EOL%            dir = isStart? dirOut : dirIn;%EOL%        }%EOL%        else%EOL%        {%EOL%            vec2 tangent = normalize(dirIn+dirOut);%EOL%            vec2 perp = vec2(-dirIn.y, dirIn.x);%EOL%            vec2 miter = vec2(-tangent.y, tangent.x);%EOL%            dir = tangent;%EOL%            len = thickness / dot(miter, perp);%EOL%%EOL%            // limit the length of a mitered corner, to prevent unsightly spikes%EOL%            const float limit = 2.0;%EOL%            if (len > thickness*limit)%EOL%            {%EOL%                len = thickness;%EOL%                dir = isStart? dirOut : dirIn;%EOL%            }%EOL%        }%EOL%%EOL%        stippleDir = dirOut;%EOL%    }%EOL%%EOL%    // calculate the extrusion vector in pixels%EOL%    // note: seems like it should be len/2, BUT remember we are in [-w..w] space%EOL%    vec2 extrudePixel = vec2(-dir.y, dir.x) * len;%EOL%%EOL%    // and convert to unit space:%EOL%    vec2 extrudeUnit = extrudePixel / oe_Camera.xy;%EOL%        %EOL%    // calculate the offset in clip space and apply it.%EOL%    vec2 offset = extrudeUnit * oe_LineDrawable_lateral * currClip.w;%EOL%    currClip.xy += offset;%EOL%%EOL%    // prepare for stippling:%EOL%    if (oe_GL_LineStipplePattern != 0xffff)%EOL%    {%EOL%        // Line creation is done. Now, calculate a rotation angle%EOL%        // for use by out fragment shader to do GPU stippling. %EOL%        // This %QUOTE%rotates%QUOTE% the fragment coordinate onto the X axis so that%EOL%        // we can apply stippling along the direction of the line.%EOL%        // Note: this depends on the GLSL %QUOTE%provoking vertex%QUOTE% being at the %EOL%        // beginning of the line segment!%EOL%%EOL%        // calculate the rotation angle that will project the%EOL%        // fragment coord onto the X-axis for stipple pattern sampling.%EOL%        float way = sign(cross(vec3(1, 0, 0), vec3(-stippleDir, 0)).z);%EOL%        float angle = acos(dot(vec2(1, 0), -stippleDir)) * way;%EOL%%EOL%        // quantize the rotation angle to mitigate precision problems%EOL%        // when connecting segments with slightly different vectors%EOL%        const float pi = 3.14159265359;%EOL%        const float q = pi/8.0;%EOL%        angle = floor(angle/q) * q;%EOL%%EOL%        // send it to the fragment shader.%EOL%        oe_LineDrawable_rv = vec2(cos(angle), sin(angle));%EOL%    }%EOL%}%EOL%%EOL%%EOL%[break]%EOL%%EOL%#version $GLSL_VERSION_STR%EOL%%EOL%#pragma vp_name GPU Lines Screen Projected FS%EOL%#pragma vp_entryPoint oe_LineDrawable_Stippler_FS%EOL%#pragma vp_location fragment_coloring%EOL%#pragma import_defines(OE_LINE_SMOOTH)%EOL%%EOL%uniform int oe_GL_LineStippleFactor;%EOL%uniform int oe_GL_LineStipplePattern;%EOL%%EOL%flat in vec2 oe_LineDrawable_rv;%EOL%flat in int oe_LineDrawable_draw;%EOL%%EOL%#ifdef OE_LINE_SMOOTH%EOL%in float oe_LineDrawable_lateral;%EOL%#endif%EOL%%EOL%void oe_LineDrawable_Stippler_FS(inout vec4 color)%EOL%{%EOL%    if (oe_LineDrawable_draw == 0)%EOL%        discard;%EOL%%EOL%    if (oe_GL_LineStipplePattern != 0xffff)%EOL%    {%EOL%        // coordinate of the fragment, shifted to 0:%EOL%        vec2 coord = (gl_FragCoord.xy - 0.5);%EOL%%EOL%        // rotate the frag coord onto the X-axis so we can sample the %EOL%        // stipple pattern:%EOL%        vec2 coordProj =%EOL%            mat2(oe_LineDrawable_rv.x, -oe_LineDrawable_rv.y,%EOL%                 oe_LineDrawable_rv.y,  oe_LineDrawable_rv.x)%EOL%            * coord;%EOL%%EOL%        // sample the stippling pattern (16-bits repeating)%EOL%        int ci = int(mod(coordProj.x, 16.0 * float(oe_GL_LineStippleFactor))) / oe_GL_LineStippleFactor;%EOL%        int pattern16 = 0xffff & (oe_GL_LineStipplePattern & (1 << ci));%EOL%        if (pattern16 == 0)%EOL%            discard; %EOL%%EOL%        // uncomment to debug stipple direction vectors%EOL%        //color.b = 0;%EOL%        //color.r = oe_LineDrawable_rv.x;%EOL%        //color.g = oe_LineDrawable_rv.y;%EOL%    }%EOL%%EOL%#ifdef OE_LINE_SMOOTH%EOL%    // anti-aliasing%EOL%    float L = abs(oe_LineDrawable_lateral);%EOL%    color.a = color.a * smoothstep(0.0, 1.0, 1.0-(L*L));%EOL%#endif%EOL%}%EOL%%EOL%";    

        // PointDrawable
        PointDrawable = "PointDrawable.glsl";
        _sources[PointDrawable] = "#version $GLSL_VERSION_STR%EOL%#pragma vp_name PointDrawable%EOL%#pragma vp_entryPoint oe_PointDrawable_VS_VIEW%EOL%#pragma vp_location vertex_view%EOL%#pragma vp_order last%EOL%%EOL%uniform float oe_GL_PointSize;%EOL%%EOL%void oe_PointDrawable_VS_VIEW(inout vec4 vertexView)%EOL%{%EOL%    gl_PointSize = oe_GL_PointSize;%EOL%}%EOL%%EOL%[break]%EOL%%EOL%#version $GLSL_VERSION_STR%EOL%#pragma vp_name PointDrawable FS%EOL%#pragma vp_entryPoint oe_PointDrawable_FS%EOL%#pragma vp_location fragment_coloring%EOL%#pragma import_defines(OE_POINT_SMOOTH)%EOL%%EOL%void oe_PointDrawable_FS(inout vec4 color)%EOL%{%EOL%#ifdef OE_POINT_SMOOTH%EOL%    vec2 c = 2.0*gl_PointCoord-1.0;%EOL%    float r = dot(c, c);%EOL%    float d = 0.0;%EOL%  #ifdef GL_OES_standard_derivatives%EOL%    d = fwidth(r);%EOL%  #endif%EOL%    color.a *= 1.0 - smoothstep(1.0-d, 1.0+d, r);%EOL%    if (color.a < 0.1)%EOL%        discard;%EOL%#endif%EOL%}%EOL%%EOL%";          

        // WireLines
        WireLines = "WireLines.glsl";
        _sources[WireLines] = "#version $GLSL_VERSION_STR%EOL%#pragma vp_name Wire Lines Vertex Shader Model%EOL%#pragma vp_entryPoint oe_WireLine_VS_MODEL%EOL%#pragma vp_location vertex_model%EOL%%EOL%uniform float oe_WireDrawable_radius;%EOL%%EOL%// Set by the InstallCameraUniform callback%EOL%uniform vec3 oe_Camera;%EOL%%EOL%vec3 vp_Normal;%EOL%vec4 vp_Color;%EOL%%EOL%// Scale the wire geometry so it covers at least 1 pixel, and scale%EOL%// the alpha (as coverage) to compensate. We assume that the wire is%EOL%// horizontal because we don't want the alpha value to change as the%EOL%// orientation changes.%EOL%//%EOL%// Given a point v = [x, y , z, 1] in eye space and projection matrix P,%EOL%// P * v = [xc, yc, zc, w]; yc / w = -(P[1][2] * z + p[1][1] * y) / z;%EOL%// the derivative diff(yc, y) gives the clip space change in height%EOL%// with respect to a change in eye space y. diff(yc, y) = -p[1][1] / z,%EOL%// or p[1][1] / w.%EOL%//%EOL%// Clip space goes from -1 to 1, so the pixel height of an object with%EOL%// a height h is screen_height * p11 * h / (2 * w).%EOL%%EOL%void oe_WireLine_VS_MODEL(inout vec4 curVertex)%EOL%{%EOL%    vec4 clipVertex = gl_ModelViewProjectionMatrix * curVertex;%EOL%    // Multiply by 2 to get diameter.%EOL%    float pixSize = (2.0 * oe_WireDrawable_radius) * oe_Camera.y * gl_ProjectionMatrix[1][1]%EOL%        / (2.0 * clipVertex.w);%EOL%    float scale = 1.0;%EOL%    if (pixSize < 1.0)%EOL%    {%EOL%        scale = 1.0 / pixSize;%EOL%        vp_Color.a = pixSize;%EOL%    }%EOL%    curVertex.xyz += vp_Normal * oe_WireDrawable_radius * scale;%EOL%}%EOL%%EOL%";

        // PhongLightingEffect
        PhongLighting = "PhongLighting.glsl";
        _sources[PhongLighting] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_name       Phong Lighting Vertex Stage%EOL%#pragma vp_entryPoint oe_phong_vertex%EOL%#pragma vp_location   vertex_view%EOL%%EOL%#pragma import_defines(OE_LIGHTING)%EOL%%EOL%%EOL%out vec3 oe_phong_vertexView3;%EOL%%EOL%void oe_phong_vertex(inout vec4 VertexVIEW)%EOL%{%EOL%#ifndef OE_LIGHTING%EOL%    return;%EOL%#endif%EOL%%EOL%    oe_phong_vertexView3 = VertexVIEW.xyz / VertexVIEW.w;%EOL%}%EOL%%EOL%%EOL%[break]%EOL%%EOL%  %EOL%#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_name       Phong Lighting Vertex Stage%EOL%#pragma vp_entryPoint oe_phong_fragment%EOL%#pragma vp_location   fragment_lighting%EOL%%EOL%#pragma import_defines(OE_LIGHTING)%EOL%#pragma import_defines(OE_NUM_LIGHTS)%EOL%%EOL%#ifdef OE_LIGHTING%EOL%%EOL%in vec3 oe_phong_vertexView3; %EOL%%EOL%// stage global%EOL%vec3 vp_Normal;%EOL%%EOL%// Parameters of each light:%EOL%struct osg_LightSourceParameters %EOL%{   %EOL%   vec4 ambient;%EOL%   vec4 diffuse;%EOL%   vec4 specular;%EOL%   vec4 position;%EOL%   vec3 spotDirection;%EOL%   float spotExponent;%EOL%   float spotCutoff;%EOL%   float spotCosCutoff;%EOL%   float constantAttenuation;%EOL%   float linearAttenuation;%EOL%   float quadraticAttenuation;%EOL%%EOL%   bool enabled;%EOL%};  %EOL%uniform osg_LightSourceParameters osg_LightSource[OE_NUM_LIGHTS];%EOL%%EOL%// Surface material:%EOL%struct osg_MaterialParameters  %EOL%{   %EOL%   vec4 emission;    // Ecm   %EOL%   vec4 ambient;     // Acm   %EOL%   vec4 diffuse;     // Dcm   %EOL%   vec4 specular;    // Scm   %EOL%   float shininess;  // Srm  %EOL%};  %EOL%uniform osg_MaterialParameters osg_FrontMaterial; %EOL%%EOL%void oe_phong_fragment(inout vec4 color) %EOL%{%EOL%    // See:%EOL%    // https://en.wikipedia.org/wiki/Phong_reflection_model%EOL%    // https://www.opengl.org/sdk/docs/tutorials/ClockworkCoders/lighting.php%EOL%    // https://en.wikibooks.org/wiki/GLSL_Programming/GLUT/Multiple_Lights%EOL%%EOL%    vec3 N = normalize(vp_Normal);%EOL%%EOL%    float shine = clamp(osg_FrontMaterial.shininess, 1.0, 128.0);%EOL%    vec3 surfaceSpecularity = osg_FrontMaterial.specular.rgb;%EOL%%EOL%    // Accumulate the lighting, starting with material emission.%EOL%    vec3 totalDiffuse = vec3(0.0);%EOL%    vec3 totalAmbient = vec3(0.0);%EOL%    vec3 totalSpecular = vec3(0.0);%EOL%    %EOL%    int numLights = OE_NUM_LIGHTS; //min(osg_NumLights, MAX_LIGHTS);%EOL%%EOL%    for (int i=0; i<numLights; ++i)%EOL%    {%EOL%        if (osg_LightSource[i].enabled)%EOL%        {%EOL%            float attenuation = 1.0;%EOL%%EOL%            // L is the normalized camera-to-light vector.%EOL%            vec3 L = normalize(osg_LightSource[i].position.xyz);%EOL%%EOL%            // V is the normalized vertex-to-camera vector.%EOL%            vec3 V = -normalize(oe_phong_vertexView3);%EOL%%EOL%            // point or spot light:%EOL%            if (osg_LightSource[i].position.w != 0.0)%EOL%            {%EOL%                // calculate VL, the vertex-to-light vector:%EOL%                vec4 VL = vec4(oe_phong_vertexView3, 1.0) * osg_LightSource[i].position.w;%EOL%                vec4 VL4 = osg_LightSource[i].position - VL;%EOL%                L = normalize(VL4.xyz);%EOL%%EOL%                // calculate attenuation:%EOL%                float distance = length(VL4);%EOL%                attenuation = 1.0 / (%EOL%                    osg_LightSource[i].constantAttenuation +%EOL%                    osg_LightSource[i].linearAttenuation * distance +%EOL%                    osg_LightSource[i].quadraticAttenuation * distance * distance);%EOL%%EOL%                // for a spot light, the attenuation help form the cone:%EOL%                if (osg_LightSource[i].spotCutoff <= 90.0)%EOL%                {%EOL%                    vec3 D = normalize(osg_LightSource[i].spotDirection);%EOL%                    float clampedCos = max(0.0, dot(-L,D));%EOL%                    attenuation = clampedCos < osg_LightSource[i].spotCosCutoff ?%EOL%                        0.0 :%EOL%                        attenuation * pow(clampedCos, osg_LightSource[i].spotExponent);%EOL%                }%EOL%            }%EOL%%EOL%            vec3 ambientReflection =%EOL%                attenuation%EOL%                * osg_LightSource[i].ambient.rgb;%EOL%%EOL%            float NdotL = max(dot(N,L), 0.0); %EOL%%EOL%            vec3 diffuseReflection =%EOL%                attenuation%EOL%                * osg_LightSource[i].diffuse.rgb%EOL%                * NdotL;%EOL%                %EOL%            vec3 specularReflection = vec3(0.0);%EOL%            if (NdotL > 0.0)%EOL%            {%EOL%                vec3 H = reflect(-L,N); %EOL%                float HdotV = max(dot(H,V), 0.0); %EOL%%EOL%                specularReflection =%EOL%                    attenuation%EOL%                    * osg_LightSource[i].specular.rgb%EOL%                    * surfaceSpecularity%EOL%                    * pow(HdotV, shine);%EOL%            }%EOL%%EOL%            totalDiffuse += diffuseReflection;%EOL%            totalAmbient += ambientReflection;%EOL%            totalSpecular += specularReflection;%EOL%        }%EOL%    }%EOL%%EOL%    vec3 lightColor =%EOL%        osg_FrontMaterial.emission.rgb +%EOL%        totalDiffuse * osg_FrontMaterial.diffuse.rgb +%EOL%        totalAmbient * osg_FrontMaterial.ambient.rgb;%EOL%%EOL%    color.rgb =%EOL%        color.rgb * lightColor +%EOL%        totalSpecular;%EOL%}%EOL%%EOL%#else%EOL%%EOL%// nop%EOL%void oe_phong_fragment(inout vec4 color) { }%EOL%%EOL%#endif%EOL%%EOL%";

		// Text
		Text = "Text.glsl";
		_sources[Text] = "#version $GLSL_VERSION_STR%EOL%%EOL%out vec2 oe_Text_texCoord;%EOL%%EOL%#pragma vp_entryPoint oe_Text_VS%EOL%#pragma vp_location   vertex_view%EOL%%EOL%void oe_Text_VS(inout vec4 position)%EOL%{%EOL%    oe_Text_texCoord = gl_MultiTexCoord0.xy;%EOL%}%EOL%%EOL%%EOL%[break]%EOL%%EOL%#version $GLSL_VERSION_STR%EOL%%EOL%#ifdef GL_ES%EOL%    #extension GL_OES_standard_derivatives : enable%EOL%    #ifndef GL_OES_standard_derivatives%EOL%        #undef SIGNED_DISTANCE_FIELD%EOL%    #endif%EOL%#endif%EOL%%EOL%#if !defined(GL_ES)%EOL%    #if __VERSION__>=400%EOL%        #define osg_TextureQueryLOD textureQueryLod%EOL%    #else%EOL%        #extension GL_ARB_texture_query_lod : enable%EOL%        #ifdef GL_ARB_texture_query_lod%EOL%            #define osg_TextureQueryLOD textureQueryLOD%EOL%        #endif%EOL%    #endif%EOL%#endif%EOL%%EOL%#pragma vp_entryPoint oe_Text_FS%EOL%#pragma vp_location   fragment_coloring%EOL%%EOL%#pragma import_defines(BACKDROP_COLOR, SHADOW, OUTLINE)%EOL%#pragma import_defines(SIGNED_DISTANCE_FIELD, TEXTURE_DIMENSION, GLYPH_DIMENSION)%EOL%#pragma import_defines(OSGTEXT_GLYPH_ALPHA_FORMAT_IS_RED)%EOL%%EOL%#if __VERSION__>=130%EOL%    #define TEXTURE texture%EOL%    #define TEXTURELOD textureLod%EOL%#else%EOL%    #define TEXTURE texture2D%EOL%    #define TEXTURELOD texture2DLod%EOL%#endif%EOL%%EOL%%EOL%//#if !defined(GL_ES) && __VERSION__>=130%EOL%#ifdef OSGTEXT_GLYPH_ALPHA_FORMAT_IS_RED%EOL%    #define ALPHA r%EOL%    #define SDF g%EOL%#else%EOL%    #define ALPHA a%EOL%    #define SDF r%EOL%#endif%EOL%%EOL%%EOL%uniform sampler2D glyphTexture;%EOL%%EOL%in vec2 oe_Text_texCoord;%EOL%vec4 vertexColor;%EOL%%EOL%#ifndef TEXTURE_DIMENSION%EOL%    #define TEXTURE_DIMENSION float(1024.0)%EOL%#endif%EOL%%EOL%#ifndef GLYPH_DIMENSION%EOL%    #define GLYPH_DIMENSION float(32.0)%EOL%#endif%EOL%%EOL%#ifdef SIGNED_DISTANCE_FIELD%EOL%%EOL%float distanceFromEdge(vec2 tc)%EOL%{%EOL%    float center_alpha = TEXTURELOD(glyphTexture, tc, 0.0).SDF;%EOL%    if (center_alpha==0.0) return -1.0;%EOL%%EOL%    //float distance_scale = (1.0/4.0)*1.41;%EOL%    float distance_scale = (1.0/6.0)*1.41;%EOL%    //float distance_scale = (1.0/8.0)*1.41;%EOL%%EOL%    return (center_alpha-0.5)*distance_scale;%EOL%}%EOL%%EOL%vec4 distanceFieldColorSample(float edge_distance, float blend_width, float  blend_half_width)%EOL%{%EOL%#ifdef OUTLINE%EOL%    float outline_width = OUTLINE*0.5;%EOL%    if (edge_distance>blend_half_width)%EOL%    {%EOL%        return vertexColor;%EOL%    }%EOL%    else if (edge_distance>-blend_half_width)%EOL%    {%EOL%        return mix(vertexColor, vec4(BACKDROP_COLOR.rgb, BACKDROP_COLOR.a*vertexColor.a), smoothstep(0.0, 1.0, (blend_half_width-edge_distance)/(blend_width)));%EOL%    }%EOL%    else if (edge_distance>(blend_half_width-outline_width))%EOL%    {%EOL%        return vec4(BACKDROP_COLOR.rgb, BACKDROP_COLOR.a*vertexColor.a);%EOL%    }%EOL%    else if (edge_distance>-(outline_width+blend_half_width))%EOL%    {%EOL%        return vec4(BACKDROP_COLOR.rgb, vertexColor.a * ((blend_half_width+outline_width+edge_distance)/blend_width));%EOL%    }%EOL%    else%EOL%    {%EOL%        return vec4(0.0, 0.0, 0.0, 0.0);%EOL%    }%EOL%#else%EOL%    if (edge_distance>blend_half_width)%EOL%    {%EOL%        return vertexColor;%EOL%    }%EOL%    else if (edge_distance>-blend_half_width)%EOL%    {%EOL%        return vec4(vertexColor.rgb, vertexColor.a * smoothstep(1.0, 0.0, (blend_half_width-edge_distance)/(blend_width)));%EOL%    }%EOL%    else%EOL%    {%EOL%        return vec4(0.0, 0.0, 0.0, 0.0);%EOL%    }%EOL%#endif%EOL%}%EOL%%EOL%vec4 textColor(vec2 src_texCoord)%EOL%{%EOL%    float sample_distance_scale = 0.75;%EOL%    vec2 dx = dFdx(src_texCoord)*sample_distance_scale;%EOL%    vec2 dy = dFdy(src_texCoord)*sample_distance_scale;%EOL%%EOL%%EOL%    float distance_across_pixel = length(dx+dy)*(TEXTURE_DIMENSION/GLYPH_DIMENSION);%EOL%%EOL%    // compute the appropriate number of samples required to avoid aliasing.%EOL%    int maxNumSamplesAcrossSide = 4;%EOL%%EOL%    int numSamplesX = int(TEXTURE_DIMENSION * length(dx));%EOL%    int numSamplesY = int(TEXTURE_DIMENSION * length(dy));%EOL%    if (numSamplesX<2) numSamplesX = 2;%EOL%    if (numSamplesY<2) numSamplesY = 2;%EOL%    if (numSamplesX>maxNumSamplesAcrossSide) numSamplesX = maxNumSamplesAcrossSide;%EOL%    if (numSamplesY>maxNumSamplesAcrossSide) numSamplesY = maxNumSamplesAcrossSide;%EOL%%EOL%%EOL%    vec2 delta_tx = dx/float(numSamplesX-1);%EOL%    vec2 delta_ty = dy/float(numSamplesY-1);%EOL%%EOL%    float numSamples = float(numSamplesX)*float(numSamplesY);%EOL%    float scale = 1.0/numSamples;%EOL%    vec4 total_color = vec4(0.0,0.0,0.0,0.0);%EOL%%EOL%    float blend_width = 1.5*distance_across_pixel/numSamples;%EOL%    float blend_half_width = blend_width*0.5;%EOL%%EOL%    // check whether fragment is wholly within or outwith glyph body+outline%EOL%    float cd = distanceFromEdge(src_texCoord); // central distance (distance from center to edge)%EOL%    if (cd-blend_half_width>distance_across_pixel) return vertexColor; // pixel fully within glyph body%EOL%%EOL%    #ifdef OUTLINE%EOL%    float outline_width = OUTLINE*0.5;%EOL%    if ((-cd-outline_width-blend_half_width)>distance_across_pixel) return vec4(0.0, 0.0, 0.0, 0.0); // pixel fully outside outline+glyph body%EOL%    #else%EOL%    if (-cd-blend_half_width>distance_across_pixel) return vec4(0.0, 0.0, 0.0, 0.0); // pixel fully outside glyph body%EOL%    #endif%EOL%%EOL%%EOL%    // use multi-sampling to provide high quality antialised fragments%EOL%    vec2 origin = src_texCoord - dx*0.5 - dy*0.5;%EOL%    for(;numSamplesY>0; --numSamplesY)%EOL%    {%EOL%        vec2 pos = origin;%EOL%        int numX = numSamplesX;%EOL%        for(;numX>0; --numX)%EOL%        {%EOL%            vec4 c = distanceFieldColorSample(distanceFromEdge(pos), blend_width, blend_half_width);%EOL%            total_color = total_color + c * c.a;%EOL%            pos += delta_tx;%EOL%        }%EOL%        origin += delta_ty;%EOL%    }%EOL%%EOL%    total_color.rgb /= total_color.a;%EOL%    total_color.a *= scale;%EOL%%EOL%    return total_color;%EOL%}%EOL%%EOL%#else%EOL%%EOL%vec4 textColor(vec2 src_texCoord)%EOL%{%EOL%%EOL%#ifdef OUTLINE%EOL%%EOL%    float alpha = TEXTURE(glyphTexture, src_texCoord).ALPHA;%EOL%    float delta_tc = 1.6*OUTLINE*GLYPH_DIMENSION/TEXTURE_DIMENSION;%EOL%%EOL%    float outline_alpha = alpha;%EOL%    vec2 origin = src_texCoord-vec2(delta_tc*0.5, delta_tc*0.5);%EOL%%EOL%    float numSamples = 3.0;%EOL%    delta_tc = delta_tc/(numSamples-1.0);%EOL%%EOL%    float background_alpha = 1.0;%EOL%%EOL%    for(float i=0.0; i<numSamples; ++i)%EOL%    {%EOL%        for(float j=0.0; j<numSamples; ++j)%EOL%        {%EOL%            float local_alpha = TEXTURE(glyphTexture, origin + vec2(i*delta_tc, j*delta_tc)).ALPHA;%EOL%            outline_alpha = max(outline_alpha, local_alpha);%EOL%            background_alpha = background_alpha * (1.0-local_alpha);%EOL%        }%EOL%    }%EOL%%EOL%    #ifdef osg_TextureQueryLOD%EOL%        float mipmapLevel = osg_TextureQueryLOD(glyphTexture, src_texCoord).x;%EOL%        if (mipmapLevel<1.0)%EOL%        {%EOL%            outline_alpha = mix(1.0-background_alpha, outline_alpha, mipmapLevel/1.0);%EOL%        }%EOL%    #endif%EOL%%EOL%    if (outline_alpha<alpha) outline_alpha = alpha;%EOL%    if (outline_alpha>1.0) outline_alpha = 1.0;%EOL%%EOL%    if (outline_alpha==0.0) return vec4(0.0, 0.0, 0.0, 0.0); // outside glyph and outline%EOL%%EOL%    vec4 color = mix(BACKDROP_COLOR, vertexColor, smoothstep(0.0, 1.0, alpha));%EOL%    color.a = vertexColor.a * smoothstep(0.0, 1.0, outline_alpha);%EOL%%EOL%    return color;%EOL%%EOL%#else%EOL%%EOL%    float alpha = TEXTURE(glyphTexture, src_texCoord).ALPHA;%EOL%    if (alpha==0.0) vec4(0.0, 0.0, 0.0, 0.0);%EOL%    return vec4(vertexColor.rgb, vertexColor.a * alpha);%EOL%%EOL%#endif%EOL%}%EOL%%EOL%#endif%EOL%%EOL%void oe_Text_FS(inout vec4 color)%EOL%{%EOL%    float originalAlpha = color.a;%EOL%    vertexColor = vec4(color.rgb, 1.0);%EOL%%EOL%    if (oe_Text_texCoord.x<0.0 && oe_Text_texCoord.y<0.0)%EOL%    {%EOL%        return;%EOL%    }%EOL%%EOL%#ifdef SHADOW%EOL%    float scale = -1.0*GLYPH_DIMENSION/TEXTURE_DIMENSION;%EOL%    vec2 delta_tc = SHADOW*scale;%EOL%    vec4 shadow_color = textColor(oe_Text_texCoord+delta_tc);%EOL%    shadow_color.rgb = BACKDROP_COLOR.rgb;%EOL%%EOL%    vec4 glyph_color = textColor(oe_Text_texCoord);%EOL%%EOL%    // lower the alpha_power value the greater the saturation, no need to be so aggressive with SDF than GREYSCALE%EOL%    #if SIGNED_DISTANCE_FIELD%EOL%        float alpha_power = 0.6;%EOL%    #else%EOL%        float alpha_power = 0.5;%EOL%    #endif%EOL%%EOL%    // over saturate the alpha values to make sure the font and it's shadow are clear%EOL%    shadow_color.a = pow(shadow_color.a, alpha_power);%EOL%    glyph_color.a = pow(glyph_color.a, alpha_power);%EOL%    vec4 clr = mix(shadow_color, glyph_color, glyph_color.a);%EOL%#else%EOL%    vec4 clr = textColor(oe_Text_texCoord);%EOL%#endif%EOL%%EOL%    if (clr.a==0.0) discard;%EOL%%EOL%    color = clr;%EOL%    color.a *= originalAlpha;%EOL%}%EOL%%EOL%";

        TextLegacy = "Text_legacy.glsl";
        _sources[TextLegacy] = "#version $GLSL_VERSION_STR%EOL%#pragma vp_entryPoint oe_Text_VS%EOL%#pragma vp_location   vertex_view%EOL%%EOL%out vec2 oe_Text_texcoord;%EOL%%EOL%void oe_Text_VS(inout vec4 position)%EOL%{%EOL%    oe_Text_texcoord = gl_MultiTexCoord0.xy;%EOL%%EOL%#if !defined(GL_ES) && __VERSION__<140%EOL%    gl_ClipVertex = gl_ModelViewMatrix * gl_Vertex;%EOL%#endif%EOL%}%EOL%%EOL%[break]%EOL%%EOL%#version $GLSL_VERSION_STR%EOL%#pragma vp_entryPoint oe_Text_FS%EOL%#pragma vp_location   fragment_coloring%EOL%%EOL%uniform sampler2D glyphTexture;%EOL%in vec2 oe_Text_texcoord;%EOL%%EOL%void oe_Text_FS(inout vec4 color)%EOL%{%EOL%    color.a *= texture(glyphTexture, oe_Text_texcoord).a;%EOL%}%EOL%%EOL%";
        
        ContourMap = "ContourMap.glsl";
        _sources[ContourMap] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_contour_fragment%EOL%#pragma vp_location   fragment_coloring%EOL%#pragma vp_order 0.5%EOL%%EOL%in vec4 oe_layer_tilec;%EOL%uniform sampler1D oe_contour_xfer;%EOL%uniform float oe_contour_min;%EOL%uniform float oe_contour_range;%EOL%%EOL%float oe_terrain_getElevation(in vec2 uv);%EOL%%EOL%void oe_contour_fragment( inout vec4 color )%EOL%{%EOL%    float height = oe_terrain_getElevation(oe_layer_tilec.st);%EOL%    float height_normalized = (height-oe_contour_min)/oe_contour_range;%EOL%    float lookup = clamp( height_normalized, 0.0, 1.0 );%EOL%    vec4 texel = texture( oe_contour_xfer, lookup );%EOL%    color.rgb = mix(color.rgb, texel.rgb, texel.a);%EOL%}%EOL%%EOL%";

        LogDepthBuffer = "LogDepthBuffer.glsl";
        _sources[LogDepthBuffer] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_logDepth_vert%EOL%#pragma vp_location   vertex_clip%EOL%#pragma vp_order      0.99%EOL%%EOL%out float oe_LogDepth_logz;%EOL%%EOL%void oe_logDepth_vert(inout vec4 clip)%EOL%{%EOL%    if (gl_ProjectionMatrix[3][3] == 0) // perspective only%EOL%    {%EOL%        mat4 clip2view = inverse(gl_ProjectionMatrix);%EOL%        vec4 farPoint = clip2view * vec4(0,0,1,1);%EOL%        float FAR = -farPoint.z / farPoint.w;%EOL%%EOL%        const float C = 0.001;%EOL%        float FC = 1.0 / log(FAR*C + 1);%EOL%        oe_LogDepth_logz = log(max(1e-6, clip.w*C + 1.0))*FC;%EOL%        clip.z = (2.0*oe_LogDepth_logz - 1.0)*clip.w;%EOL%    }%EOL%    else%EOL%    {%EOL%        oe_LogDepth_logz = -1.0;%EOL%    }%EOL%}%EOL%%EOL%[break]%EOL%%EOL%#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_logDepth_frag%EOL%#pragma vp_location   fragment_lighting%EOL%#pragma vp_order      0.99%EOL%%EOL%in float oe_LogDepth_logz;%EOL%%EOL%void oe_logDepth_frag(inout vec4 color)%EOL%{%EOL%    gl_FragDepth = oe_LogDepth_logz >= 0? oe_LogDepth_logz : gl_FragCoord.z;%EOL%}%EOL%%EOL%";

        LogDepthBuffer_VertOnly = "LogDepthBuffer.VertOnly.glsl";
        _sources[LogDepthBuffer_VertOnly] = "#version $GLSL_VERSION_STR%EOL%%EOL%#pragma vp_entryPoint oe_logDepth_vert%EOL%#pragma vp_location   vertex_clip%EOL%#pragma vp_order      0.99%EOL%%EOL%void oe_logDepth_vert(inout vec4 clip)%EOL%{%EOL%    if (gl_ProjectionMatrix[3][3] == 0.0) // perspective only%EOL%    {%EOL%        mat4 clip2view = inverse(gl_ProjectionMatrix);%EOL%        vec4 farPoint = clip2view * vec4(0,0,1,1);%EOL%        float FAR = -farPoint.z / farPoint.w;%EOL%%EOL%        float FC = 2.0 / log2(FAR + 1);%EOL%        clip.z = (log2(max(1e-6, clip.w+1.0))*FC - 1.0) * clip.w;%EOL%    }%EOL%}%EOL%%EOL%";

        GeodeticGraticule = "GeodeticGraticule.glsl";
        _sources[GeodeticGraticule] = "#version $GLSL_VERSION_STR%EOL%%EOL%#pragma vp_entryPoint oe_GeodeticGraticule_vertex%EOL%#pragma vp_location   vertex_view%EOL%#pragma vp_order      0.5%EOL%%EOL%#pragma import_defines(OE_DISABLE_GRATICULE)%EOL%%EOL%uniform vec4 oe_tile_key;%EOL%out vec4 oe_layer_tilec;%EOL%out vec2 oe_GeodeticGraticule_coord;%EOL%%EOL%%EOL%void oe_GeodeticGraticule_vertex(inout vec4 vertex)%EOL%{%EOL%#ifndef OE_DISABLE_GRATICULE%EOL%    // calculate long and lat from [0..1] across the profile:%EOL%    vec2 r = (oe_tile_key.xy + oe_layer_tilec.xy)/exp2(oe_tile_key.z);%EOL%    oe_GeodeticGraticule_coord = vec2(0.5*r.x, r.y);%EOL%#endif%EOL%}%EOL%%EOL%%EOL%[break]%EOL%%EOL%#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_GeodeticGraticule_fragment%EOL%#pragma vp_location   fragment_lighting%EOL%#pragma vp_order      1.1%EOL%%EOL%#pragma import_defines(OE_DISABLE_GRATICULE)%EOL%%EOL%uniform float oe_GeodeticGraticule_lineWidth;%EOL%uniform float oe_GeodeticGraticule_resolution;%EOL%uniform vec4  oe_GeodeticGraticule_color;%EOL%uniform mat4 osg_ViewMatrixInverse;%EOL%%EOL%in vec2 oe_GeodeticGraticule_coord;%EOL%%EOL%void oe_GeodeticGraticule_fragment(inout vec4 color)%EOL%{%EOL%#ifndef OE_DISABLE_GRATICULE%EOL%    // double the effective res for longitude since it has twice the span%EOL%    vec2 gr = vec2(0.5*oe_GeodeticGraticule_resolution, oe_GeodeticGraticule_resolution);%EOL%    vec2 distanceToLine = mod(oe_GeodeticGraticule_coord, gr);%EOL%    vec2 dx = abs(dFdx(oe_GeodeticGraticule_coord));%EOL%    vec2 dy = abs(dFdy(oe_GeodeticGraticule_coord));%EOL%    vec2 dF = vec2(max(dx.s, dy.s), max(dx.t, dy.t)) * oe_GeodeticGraticule_lineWidth;%EOL%%EOL%    if ( any(lessThan(distanceToLine, dF)))%EOL%    {%EOL%        // calculate some anti-aliasing%EOL%        vec2 f = distanceToLine/dF;%EOL%        float antialias = 1.0 - 2.0*abs(0.5 - min(f.x,f.y));%EOL%%EOL%        // Fade out the lines as you get closer to the ground.%EOL%        vec3 eye = osg_ViewMatrixInverse[3].xyz;%EOL%        float hae = length(eye) - 6378137.0;%EOL%        float maxHAE = 2000.0;%EOL%        float alpha = clamp(hae / maxHAE, 0.0, 1.0) * antialias;%EOL%        color.rgb = mix(color.rgb, oe_GeodeticGraticule_color.rgb, oe_GeodeticGraticule_color.a * alpha);%EOL%    }%EOL%#endif%EOL%}%EOL%%EOL%";

        ShadowCaster = "ShadowCaster.glsl";
        _sources[ShadowCaster] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_name       Shadowing Vertex Shader%EOL%#pragma vp_entryPoint oe_shadow_vertex%EOL%#pragma vp_location   vertex_view%EOL%#pragma vp_order      last%EOL%%EOL%%EOL%uniform mat4 oe_shadow_matrix[$OE_SHADOW_NUM_SLICES];%EOL%%EOL%out vec4 oe_shadow_coord[$OE_SHADOW_NUM_SLICES];%EOL%%EOL%void oe_shadow_vertex(inout vec4 VertexVIEW)%EOL%{%EOL%    for(int i=0; i < $OE_SHADOW_NUM_SLICES; ++i)%EOL%    {%EOL%        oe_shadow_coord[i] = oe_shadow_matrix[i] * VertexVIEW;%EOL%    }%EOL%}%EOL%%EOL%%EOL%[break]%EOL%%EOL%#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_name       Shadowing Fragment Shader%EOL%#pragma vp_entryPoint oe_shadow_fragment%EOL%#pragma vp_location   fragment_lighting%EOL%#pragma vp_order      0.9%EOL%%EOL%#pragma import_defines(OE_LIGHTING, OE_NUM_LIGHTS)%EOL%%EOL%uniform sampler2DArray oe_shadow_map;%EOL%uniform float          oe_shadow_color;%EOL%uniform float          oe_shadow_blur;%EOL%%EOL%in vec3 vp_Normal; // stage global%EOL%in vec4 oe_shadow_coord[$OE_SHADOW_NUM_SLICES];%EOL%%EOL%// Parameters of each light:%EOL%struct osg_LightSourceParameters %EOL%{   %EOL%   vec4 ambient;%EOL%   vec4 diffuse;%EOL%   vec4 specular;%EOL%   vec4 position;%EOL%   vec3 spotDirection;%EOL%   float spotExponent;%EOL%   float spotCutoff;%EOL%   float spotCosCutoff;%EOL%   float constantAttenuation;%EOL%   float linearAttenuation;%EOL%   float quadraticAttenuation;%EOL%%EOL%   bool enabled;%EOL%};  %EOL%uniform osg_LightSourceParameters osg_LightSource[OE_NUM_LIGHTS];%EOL%%EOL%%EOL%#define OE_SHADOW_NUM_SAMPLES 16%EOL%%EOL%const vec2 oe_shadow_samples[16] = vec2[](%EOL%    vec2( -0.942016, -0.399062 ), vec2( 0.945586, -0.768907 ), vec2( -0.094184, -0.929389 ), vec2( 0.344959, 0.293878 ),%EOL%    vec2( -0.915886, 0.457714 ), vec2( -0.815442, -0.879125 ), vec2( -0.382775, 0.276768 ), vec2( 0.974844, 0.756484 ),%EOL%    vec2( 0.443233, -0.975116 ), vec2( 0.53743, -0.473734 ), vec2( -0.264969, -0.41893 ), vec2( 0.791975, 0.190909 ),%EOL%    vec2( -0.241888, 0.997065 ), vec2( -0.8141, 0.914376 ), vec2( 0.199841, 0.786414 ), vec2( 0.143832, -0.141008 )%EOL%);%EOL%%EOL%float oe_shadow_rand(vec2 co)%EOL%{%EOL%   return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);%EOL%}%EOL%%EOL%vec2 oe_shadow_rot(vec2 p, float a)%EOL%{%EOL%    vec2 sincos = vec2(sin(a), cos(a));%EOL%    return vec2(dot(p, vec2(sincos.y, -sincos.x)), dot(p, sincos.xy));%EOL%}%EOL%%EOL%// slow PCF sampling.%EOL%float oe_shadow_multisample(in vec3 c, in float refvalue, in float blur)%EOL%{%EOL%    float shadowed = 0.0;%EOL%    float randomAngle = 6.283185 * oe_shadow_rand(c.xy);%EOL%    for(int i=0; i<OE_SHADOW_NUM_SAMPLES; ++i)%EOL%    {%EOL%        vec2 off = oe_shadow_rot(oe_shadow_samples[i], randomAngle);%EOL%        vec3 pc = vec3(c.xy + off*blur, c.z);%EOL%        float depth = texture(oe_shadow_map, pc).r;%EOL%        %EOL%        if (depth < 1.0 && depth < refvalue )%EOL%        {%EOL%           shadowed += 1.0;%EOL%        }%EOL%    }%EOL%    return 1.0-(shadowed/OE_SHADOW_NUM_SAMPLES);%EOL%}%EOL%%EOL%void oe_shadow_fragment(inout vec4 color)%EOL%{%EOL%    float alpha = color.a;%EOL%    float factor = 1.0;%EOL%%EOL%    // pre-pixel biasing to reduce moire/acne%EOL%    const float b0 = 0.001;%EOL%    const float b1 = 0.01;%EOL%    vec3 L = normalize(osg_LightSource[0].position.xyz);%EOL%    vec3 N = normalize(vp_Normal);%EOL%    float costheta = clamp(dot(L,N), 0.0, 1.0);%EOL%    float bias = b0*tan(acos(costheta));%EOL%%EOL%    float depth;%EOL%%EOL%    // loop over the slices:%EOL%    for(int i=0; i<$OE_SHADOW_NUM_SLICES && factor > 0.0; ++i)%EOL%    {%EOL%        vec4 c = oe_shadow_coord[i];%EOL%        vec3 coord = vec3(c.x, c.y, float(i));%EOL%%EOL%        // TODO: This causes an NVIDIA error (DUI_foreachId) - disable for now.%EOL%        if ( oe_shadow_blur > 0.0 )%EOL%        {%EOL%            factor = min(factor, oe_shadow_multisample(coord, c.z-bias, oe_shadow_blur));%EOL%        }%EOL%        else%EOL%        {%EOL%            //float depth = texture(oe_shadow_map, coord).r;%EOL%            depth = texture(oe_shadow_map, coord).r;%EOL%            if ( depth < 1.0 && depth < c.z-bias )%EOL%                factor = 0.0;%EOL%        }%EOL%    }%EOL%%EOL%    vec3 colorInFullShadow = color.rgb * oe_shadow_color;%EOL%    color = vec4( mix(colorInFullShadow, color.rgb, factor), alpha );%EOL%%EOL%    //color = vec4(factor, 1.0);%EOL%}%EOL%%EOL%";

        SimpleOceanLayer = "SimpleOceanLayer.glsl";
        _sources[SimpleOceanLayer] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_ocean_VS%EOL%#pragma vp_location vertex_view%EOL%%EOL%#pragma import_defines(OE_OCEAN_TEXTURE)%EOL%#pragma import_defines(OE_OCEAN_TEXTURE_LOD)%EOL%#pragma import_defines(OE_OCEAN_MASK_MATRIX)%EOL%%EOL%uniform float oe_ocean_seaLevel;%EOL%%EOL%#ifdef OE_OCEAN_TEXTURE%EOL%out vec2 oe_ocean_texCoord;%EOL%vec2 oe_terrain_scaleCoordsToRefLOD(in vec2 tc, in float refLOD); // from SDK%EOL%#endif%EOL%%EOL%#ifdef OE_OCEAN_MASK_MATRIX%EOL%out vec2 oe_ocean_maskCoord;%EOL%uniform mat4 OE_OCEAN_MASK_MATRIX ;%EOL%#endif%EOL%%EOL%vec4 oe_layer_tilec;%EOL%vec3 oe_UpVectorView;   // stage global%EOL%%EOL%void oe_ocean_VS(inout vec4 vertexView)%EOL%{%EOL%    // move the surface to the new sea level:%EOL%    vertexView.xyz += oe_UpVectorView * oe_ocean_seaLevel;%EOL%%EOL%#ifdef OE_OCEAN_TEXTURE%EOL%    oe_ocean_texCoord = oe_terrain_scaleCoordsToRefLOD(oe_layer_tilec.st, OE_OCEAN_TEXTURE_LOD);%EOL%#endif%EOL%%EOL%    // if masking, calculate the mask coordinates%EOL%#ifdef OE_OCEAN_MASK_MATRIX%EOL%    oe_ocean_maskCoord = (OE_OCEAN_MASK_MATRIX * oe_layer_tilec).st;%EOL%#endif%EOL%}%EOL%%EOL%%EOL%[break]%EOL%%EOL%#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_ocean_FS%EOL%#pragma vp_location fragment_coloring%EOL%%EOL%#pragma import_defines(OE_OCEAN_TEXTURE)%EOL%#pragma import_defines(OE_OCEAN_MASK)%EOL%#pragma import_defines(OE_OCEAN_USE_BATHYMETRY)%EOL%%EOL%float oe_terrain_getElevation();%EOL%%EOL%//in float oe_layer_opacity; // from VisibleLayer%EOL%%EOL%uniform vec4 oe_ocean_color;%EOL%uniform float oe_ocean_seaLevel;%EOL%%EOL%#ifdef OE_OCEAN_TEXTURE%EOL%in vec2 oe_ocean_texCoord;%EOL%uniform sampler2D OE_OCEAN_TEXTURE ;%EOL%#endif%EOL%%EOL%#ifdef OE_OCEAN_MASK%EOL%in vec2 oe_ocean_maskCoord;%EOL%uniform sampler2D OE_OCEAN_MASK ;%EOL%#endif%EOL%%EOL%// remaps a value from [vmin..vmax] to [0..1] clamped%EOL%float oe_ocean_remap(float val, float vmin, float vmax, float r0, float r1)%EOL%{%EOL%    float vr = (clamp(val, vmin, vmax)-vmin)/(vmax-vmin);%EOL%    return r0 + vr * (r1-r0);%EOL%}%EOL%%EOL%// entry point.%EOL%void oe_ocean_FS(inout vec4 color)%EOL%{%EOL%    float alpha = 1.0;%EOL%%EOL%#ifdef OE_OCEAN_USE_BATHYMETRY%EOL%    const float lowF = -100.0;%EOL%    const float hiF = -10.0;%EOL%%EOL%    float elevation = oe_terrain_getElevation();%EOL%    alpha = oe_ocean_remap(elevation, oe_ocean_seaLevel+lowF, oe_ocean_seaLevel+hiF, 1.0, 0.0);%EOL%#endif%EOL%%EOL%#ifdef OE_OCEAN_MASK%EOL%    float mask = texture(OE_OCEAN_MASK, oe_ocean_maskCoord).a;%EOL%    alpha *= mask;%EOL%#endif%EOL%%EOL%    color = vec4(oe_ocean_color.rgb, alpha*oe_ocean_color.a);%EOL%%EOL%#ifdef OE_OCEAN_TEXTURE%EOL%    color *= texture(OE_OCEAN_TEXTURE, oe_ocean_texCoord);%EOL%#endif%EOL%}%EOL%%EOL%";
        
        RTTPicker = "RTTPicker.glsl";
        _sources[RTTPicker] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_pick_encodeObjectID%EOL%#pragma vp_location   vertex_clip%EOL%%EOL%//#define USE_BITWISE_MATH%EOL%        %EOL%// Vertex stage global containing the Object ID; set in ObjectIndex shader.%EOL%uint oe_index_objectid;%EOL%%EOL%// output encoded oid to fragment shader%EOL%flat out vec4 oe_pick_encoded_objectid;%EOL%%EOL%// whether color already contains oid (written by another RTT camera)%EOL%flat out int oe_pick_color_contains_objectid;%EOL%%EOL%void oe_pick_encodeObjectID(inout vec4 vertex)%EOL%{%EOL%    // the color will contain an encoded object ID for draped features.%EOL%    oe_pick_color_contains_objectid = (oe_index_objectid == 1u) ? 1 : 0;%EOL%%EOL%    if ( oe_pick_color_contains_objectid == 0 )%EOL%    {%EOL%        // encode the objectID as a vec4 (color)%EOL%#ifdef USE_BITWISE_MATH%EOL%        uint u0 = (oe_index_objectid & 0xff000000u) >> 24u;%EOL%        uint u1 = (oe_index_objectid & 0x00ff0000u) >> 16u;%EOL%        uint u2 = (oe_index_objectid & 0x0000ff00u) >> 8u;%EOL%        uint u3 = (oe_index_objectid & 0x000000ffu);%EOL%#else%EOL%        uint u0 = (oe_index_objectid / 16777216u);%EOL%        uint u1 = (oe_index_objectid / 65536u) - (u0 * 256u);%EOL%        uint u2 = (oe_index_objectid / 256u) - (u1 * 256u) - (u0 * 65536u);%EOL%        uint u3 = (oe_index_objectid) - (u2 * 256u) - (u1 * 65536u) - (u0 * 16777216u);%EOL%#endif%EOL%        oe_pick_encoded_objectid = vec4(float(u0), float(u1), float(u2), float(u3)) / 255.0;%EOL%    }%EOL%}%EOL%%EOL%%EOL%[break]%EOL%%EOL%%EOL%#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_pick_renderEncodedObjectID%EOL%#pragma vp_location   fragment_output%EOL%#pragma vp_order      last%EOL%%EOL%flat in vec4 oe_pick_encoded_objectid;%EOL%flat in int oe_pick_color_contains_objectid;%EOL%        %EOL%out vec4 fragColor;%EOL%%EOL%void oe_pick_renderEncodedObjectID(inout vec4 color)%EOL%{%EOL%    if ( oe_pick_color_contains_objectid == 1 )%EOL%        fragColor = color;%EOL%    else%EOL%        fragColor = oe_pick_encoded_objectid;%EOL%}%EOL%%EOL%";
    }
} }
