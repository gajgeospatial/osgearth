// ***DO NOT EDIT THIS FILE - IT IS AUTOMATICALLY GENERATED BY CMAKE***

#include <osgEarthDrivers/sky_simple/SimpleSkyShaders>


using namespace osgEarth::SimpleSky;

Shaders::Shaders()
{
    Atmosphere_Vert = "SimpleSky.Atmosphere.vert.glsl";
    _sources[Atmosphere_Vert] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint atmos_vertex_main%EOL%#pragma vp_location   vertex_view%EOL%#pragma vp_order      0.5%EOL%%EOL%// Atmospheric Scattering and Sun Shaders%EOL%// Adapted from code that is Copyright (c) 2004 Sean ONeil%EOL%%EOL%uniform mat4 osg_ViewMatrixInverse;   // camera position in [3].xyz%EOL%uniform vec3 atmos_v3LightDir;        // The direction vector to the light source %EOL%uniform vec3 atmos_v3InvWavelength;   // 1 / pow(wavelength,4) for the rgb channels %EOL%uniform float atmos_fOuterRadius;     // Outer atmosphere radius %EOL%uniform float atmos_fOuterRadius2;    // fOuterRadius^2 		%EOL%uniform float atmos_fInnerRadius;     // Inner planetary radius %EOL%uniform float atmos_fInnerRadius2;    // fInnerRadius^2 %EOL%uniform float atmos_fKrESun;          // Kr * ESun 	%EOL%uniform float atmos_fKmESun;          // Km * ESun 		%EOL%uniform float atmos_fKr4PI;           // Kr * 4 * PI 	%EOL%uniform float atmos_fKm4PI;           // Km * 4 * PI 		%EOL%uniform float atmos_fScale;           // 1 / (fOuterRadius - fInnerRadius) 	%EOL%uniform float atmos_fScaleDepth;      // The scale depth %EOL%uniform float atmos_fScaleOverScaleDepth;     // fScale / fScaleDepth 	%EOL%uniform int atmos_nSamples; 	%EOL%uniform float atmos_fSamples; 				%EOL%%EOL%out vec3 atmos_v3Direction; %EOL%out vec3 atmos_mieColor; %EOL%out vec3 atmos_rayleighColor; %EOL%out float atmos_renderFromSpace;%EOL%%EOL%vec3 vVec; %EOL%float atmos_fCameraHeight;    // The camera's current height 		%EOL%float atmos_fCameraHeight2;   // fCameraHeight^2 %EOL%%EOL%float atmos_fastpow(in float x, in float y) %EOL%{ %EOL%    return x/(x+y-y*x); %EOL%} %EOL%%EOL%float atmos_scale(float fCos) 	%EOL%{ %EOL%    float x = 1.0 - fCos; %EOL%    return atmos_fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25)))); %EOL%} %EOL%%EOL%void atmos_SkyFromSpace(void) %EOL%{ %EOL%    // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere) %EOL%    vec3 v3Pos = gl_Vertex.xyz; %EOL%    vec3 v3Ray = v3Pos - vVec; %EOL%    float fFar = length(v3Ray); %EOL%    v3Ray /= fFar; %EOL%%EOL%    // Calculate the closest intersection of the ray with the outer atmosphere %EOL%    // (which is the near point of the ray passing through the atmosphere) %EOL%    float B = 2.0 * dot(vVec, v3Ray); %EOL%    float C = atmos_fCameraHeight2 - atmos_fOuterRadius2; %EOL%    float fDet = max(0.0, B*B - 4.0 * C); 	%EOL%    float fNear = 0.5 * (-B - sqrt(fDet)); 		%EOL%%EOL%    // Calculate the ray's starting position, then calculate its scattering offset %EOL%    vec3 v3Start = vVec + v3Ray * fNear; 			%EOL%    fFar -= fNear; 	%EOL%    float fStartAngle = dot(v3Ray, v3Start) / atmos_fOuterRadius; 			%EOL%    float fStartDepth = exp(-1.0 / atmos_fScaleDepth); %EOL%    float fStartOffset = fStartDepth*atmos_scale(fStartAngle); 		%EOL%%EOL%    // Initialize the atmos_ing loop variables 	%EOL%    float fSampleLength = fFar / atmos_fSamples; 		%EOL%    float fScaledLength = fSampleLength * atmos_fScale; 					%EOL%    vec3 v3SampleRay = v3Ray * fSampleLength; 	%EOL%    vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5; 	%EOL%%EOL%    // Now loop through the sample rays %EOL%    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0); %EOL%    vec3 v3Attenuate;   %EOL%    for(int i=0; i<atmos_nSamples; i++) 		%EOL%    { %EOL%        float fHeight = length(v3SamplePoint); 			%EOL%        float fDepth = exp(atmos_fScaleOverScaleDepth * (atmos_fInnerRadius - fHeight)); %EOL%        float fLightAngle = dot(atmos_v3LightDir, v3SamplePoint) / fHeight; 		%EOL%        float fCameraAngle = dot(v3Ray, v3SamplePoint) / fHeight; 			%EOL%        float fscatter = (fStartOffset + fDepth*(atmos_scale(fLightAngle) - atmos_scale(fCameraAngle))); 	%EOL%        v3Attenuate = exp(-fscatter * (atmos_v3InvWavelength * atmos_fKr4PI + atmos_fKm4PI)); 	%EOL%        v3FrontColor += v3Attenuate * (fDepth * fScaledLength); 					%EOL%        v3SamplePoint += v3SampleRay; 		%EOL%    } 		%EOL%%EOL%    // Finally, scale the Mie and Rayleigh colors and set up the varying 			%EOL%    // variables for the pixel shader 	%EOL%    atmos_mieColor      = v3FrontColor * atmos_fKmESun; 				%EOL%    atmos_rayleighColor = v3FrontColor * (atmos_v3InvWavelength * atmos_fKrESun); 						%EOL%    atmos_v3Direction = vVec  - v3Pos; 			%EOL%} 		%EOL%%EOL%void atmos_SkyFromAtmosphere(void) 		%EOL%{ %EOL%    // Get the ray from the camera to the vertex, and its length (which is the far %EOL%    // point of the ray passing through the atmosphere) %EOL%    vec3 v3Pos = gl_Vertex.xyz; 	%EOL%    vec3 v3Ray = v3Pos - vVec; 			%EOL%    float fFar = length(v3Ray); 					%EOL%    v3Ray /= fFar; 				%EOL%%EOL%    // Calculate the ray's starting position, then calculate its atmos_ing offset %EOL%    vec3 v3Start = vVec; %EOL%    float fHeight = length(v3Start); 		%EOL%    float fDepth = exp(atmos_fScaleOverScaleDepth * (atmos_fInnerRadius - atmos_fCameraHeight)); %EOL%    float fStartAngle = dot(v3Ray, v3Start) / fHeight; 	%EOL%    float fStartOffset = fDepth*atmos_scale(fStartAngle); %EOL%%EOL%    // Initialize the atmos_ing loop variables 		%EOL%    float fSampleLength = fFar / atmos_fSamples; 			%EOL%    float fScaledLength = fSampleLength * atmos_fScale; 				%EOL%    vec3 v3SampleRay = v3Ray * fSampleLength; 		%EOL%    vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5; %EOL%%EOL%    // Now loop through the sample rays 		%EOL%    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0); 		%EOL%    vec3 v3Attenuate;   %EOL%    for(int i=0; i<atmos_nSamples; i++) 			%EOL%    { 	%EOL%        float fHeight = length(v3SamplePoint); 	%EOL%        float fDepth = exp(atmos_fScaleOverScaleDepth * (atmos_fInnerRadius - fHeight)); %EOL%        float fLightAngle = dot(atmos_v3LightDir, v3SamplePoint) / fHeight; %EOL%        float fCameraAngle = dot(v3Ray, v3SamplePoint) / fHeight; 	%EOL%        float fscatter = (fStartOffset + fDepth*(atmos_scale(fLightAngle) - atmos_scale(fCameraAngle))); 	%EOL%        v3Attenuate = exp(-fscatter * (atmos_v3InvWavelength * atmos_fKr4PI + atmos_fKm4PI)); 	%EOL%        v3FrontColor += v3Attenuate * (fDepth * fScaledLength); 		%EOL%        v3SamplePoint += v3SampleRay; 		%EOL%    } %EOL%%EOL%    // Finally, scale the Mie and Rayleigh colors and set up the varying %EOL%    // variables for the pixel shader 					%EOL%    atmos_mieColor      = v3FrontColor * atmos_fKmESun; 			%EOL%    atmos_rayleighColor = v3FrontColor * (atmos_v3InvWavelength * atmos_fKrESun); 				%EOL%    atmos_v3Direction = vVec - v3Pos; 				%EOL%} %EOL%%EOL%uniform float FFF;%EOL%%EOL%void atmos_vertex_main(inout vec4 VertexVIEW) %EOL%{%EOL%    // Get camera position and height %EOL%    vVec = osg_ViewMatrixInverse[3].xyz; %EOL%    atmos_fCameraHeight = length(vVec); %EOL%    atmos_fCameraHeight2 = atmos_fCameraHeight*atmos_fCameraHeight; %EOL%    if(atmos_fCameraHeight >= atmos_fOuterRadius)%EOL%    { %EOL%        atmos_SkyFromSpace(); %EOL%        //atmos_renderFromSpace = 1.0;%EOL%    } %EOL%    else%EOL%    { %EOL%        atmos_SkyFromAtmosphere(); %EOL%        //atmos_renderFromSpace = 0.0;%EOL%    }%EOL%%EOL%    // Transition from space to atmosphere%EOL%    atmos_renderFromSpace = 1.0 - clamp(%EOL%        (atmos_fOuterRadius-atmos_fCameraHeight)/50000.0,%EOL%        0.0, 1.0 );%EOL%}%EOL%%EOL%";

    Atmosphere_Frag = "SimpleSky.Atmosphere.frag.glsl";
    _sources[Atmosphere_Frag] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint atmos_fragment_main%EOL%#pragma vp_location   fragment_coloring%EOL%#pragma vp_order      0.8%EOL%%EOL%uniform vec3 atmos_v3LightDir; %EOL%%EOL%uniform float atmos_g; 				%EOL%uniform float atmos_g2; %EOL%uniform float atmos_fWeather; %EOL%%EOL%in vec3 atmos_v3Direction; 	%EOL%in vec3 atmos_mieColor; %EOL%in vec3 atmos_rayleighColor; %EOL%in float atmos_renderFromSpace;%EOL%%EOL%const float fExposure = 4.0; %EOL%%EOL%float atmos_fastpow(in float x, in float y) %EOL%{ %EOL%    return x/(x+y-y*x); %EOL%} %EOL%%EOL%void atmos_fragment_main(inout vec4 color) %EOL%{%EOL%    if (gl_ProjectionMatrix[3][3] != 0.0)%EOL%        discard;%EOL%%EOL%    float fCos = dot(atmos_v3LightDir, atmos_v3Direction) / length(atmos_v3Direction); %EOL%    float fRayleighPhase = 1.0;  // 0.75 * (1.0 + fCos*fCos); %EOL%    float fMiePhase = 1.5 * ((1.0 - atmos_g2) / (2.0 + atmos_g2)) * (1.0 + fCos*fCos) / atmos_fastpow(1.0 + atmos_g2 - 2.0*atmos_g*fCos, 1.5); %EOL%    vec3 f4Color = fRayleighPhase * atmos_rayleighColor + fMiePhase * atmos_mieColor;%EOL%    %EOL%    vec3 skyColor = 1.0 - exp(f4Color * -fExposure); %EOL%    vec4 atmosColor;%EOL%    atmosColor.rgb = skyColor.rgb*atmos_fWeather; %EOL%    atmosColor.a = (skyColor.r+skyColor.g+skyColor.b) * 2.0;%EOL%%EOL%    color = mix(atmosColor, vec4(f4Color,1.0), atmos_renderFromSpace);%EOL%}%EOL%%EOL%";

    Ground_ONeil_Vert = "SimpleSky.Ground.ONeil.vert.glsl";
    _sources[Ground_ONeil_Vert] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint atmos_vertex_main%EOL%#pragma vp_location   vertex_view%EOL%#pragma vp_order      0.5%EOL%%EOL%#pragma import_defines(OE_LIGHTING)%EOL%#pragma import_defines(OE_NUM_LIGHTS)%EOL%%EOL%uniform mat4 osg_ViewMatrixInverse;   // world camera position in [3].xyz %EOL%uniform mat4 osg_ViewMatrix;          // GL view matrix %EOL%//uniform vec3 atmos_v3LightDir;        // The direction vector to the light source %EOL%uniform vec3 atmos_v3InvWavelength;   // 1 / pow(wavelength,4) for the rgb channels %EOL%uniform float atmos_fOuterRadius;     // Outer atmosphere radius %EOL%uniform float atmos_fOuterRadius2;    // fOuterRadius^2 		%EOL%uniform float atmos_fInnerRadius;     // Inner planetary radius %EOL%uniform float atmos_fInnerRadius2;    // fInnerRadius^2 %EOL%uniform float atmos_fKrESun;          // Kr * ESun 	%EOL%uniform float atmos_fKmESun;          // Km * ESun 		%EOL%uniform float atmos_fKr4PI;           // Kr * 4 * PI 	%EOL%uniform float atmos_fKm4PI;           // Km * 4 * PI 		%EOL%uniform float atmos_fScale;           // 1 / (fOuterRadius - fInnerRadius) 	%EOL%uniform float atmos_fScaleDepth;      // The scale depth %EOL%uniform float atmos_fScaleOverScaleDepth;     // fScale / fScaleDepth 	%EOL%uniform int atmos_nSamples; 	%EOL%uniform float atmos_fSamples; %EOL%%EOL%out vec3 atmos_color;          // primary sky light color%EOL%out vec3 atmos_atten;          // sky light attenuation factor%EOL%out vec3 atmos_lightDir;       // light direction in view space%EOL%        %EOL%float atmos_fCameraHeight;            // The camera's current height 		%EOL%float atmos_fCameraHeight2;           // fCameraHeight^2 %EOL%%EOL%out vec3 atmos_up;             // earth up vector at vertex location (not the normal)%EOL%out float atmos_space;         // [0..1]: camera: 0=inner radius (ground); 1.0=outer radius%EOL%out vec3 atmos_vert; %EOL%%EOL%vec3 vp_Normal;             // surface normal (from osgEarth)%EOL%%EOL%%EOL%// Toatl number of lights in the scene%EOL%//uniform int osg_NumLights;%EOL%%EOL%// Parameters of each light:%EOL%struct osg_LightSourceParameters %EOL%{   %EOL%   vec4 ambient;              // Aclarri   %EOL%   vec4 diffuse;              // Dcli   %EOL%   vec4 specular;             // Scli   %EOL%   vec4 position;             // Ppli   %EOL%   //vec4 halfVector;           // Derived: Hi   %EOL%   vec3 spotDirection;        // Sdli   %EOL%   float spotExponent;        // Srli   %EOL%   float spotCutoff;          // Crli                              %EOL%                              // (range: [0.0,90.0], 180.0)   %EOL%   float spotCosCutoff;       // Derived: cos(Crli)                 %EOL%                              // (range: [1.0,0.0],-1.0)   %EOL%   float constantAttenuation; // K0   %EOL%   float linearAttenuation;   // K1   %EOL%   float quadraticAttenuation;// K2  %EOL%%EOL%   bool enabled;%EOL%};  %EOL%uniform osg_LightSourceParameters osg_LightSource[OE_NUM_LIGHTS];%EOL%%EOL%%EOL%%EOL%float atmos_scale(float fCos) 	%EOL%{ %EOL%    float x = 1.0 - fCos; %EOL%    return atmos_fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25)))); %EOL%} %EOL%%EOL%void atmos_GroundFromSpace(in vec4 vertexVIEW) %EOL%{ %EOL%    // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere) %EOL%    vec3 v3Pos = vertexVIEW.xyz; %EOL%    vec3 v3Ray = v3Pos; %EOL%    float fFar = length(v3Ray); %EOL%    v3Ray /= fFar; %EOL%                %EOL%    vec4 ec4 = osg_ViewMatrix * vec4(0,0,0,1); %EOL%    vec3 earthCenter = ec4.xyz/ec4.w; %EOL%    vec3 normal = normalize(v3Pos-earthCenter); %EOL%    atmos_up = normal; %EOL%%EOL%    // Calculate the closest intersection of the ray with the outer atmosphere %EOL%    // (which is the near point of the ray passing through the atmosphere) %EOL%    float B = 2.0 * dot(-earthCenter, v3Ray); %EOL%    float C = atmos_fCameraHeight2 - atmos_fOuterRadius2; %EOL%    float fDet = max(0.0, B*B - 4.0*C); 	%EOL%    float fNear = 0.5 * (-B - sqrt(fDet)); 		%EOL%%EOL%    // Calculate the ray's starting position, then calculate its scattering offset %EOL%    vec3 v3Start = v3Ray * fNear; 			%EOL%    fFar -= fNear; %EOL%    float fDepth = exp((atmos_fInnerRadius - atmos_fOuterRadius) / atmos_fScaleDepth);%EOL%    float fCameraAngle = dot(-v3Ray, normal);  // try max(0, ...) to get rid of yellowing building tops%EOL%    float fLightAngle = dot(atmos_lightDir, normal); %EOL%    float fCameraScale = atmos_scale(fCameraAngle); %EOL%    float fLightScale = atmos_scale(fLightAngle); %EOL%    float fCameraOffset = fDepth*fCameraScale; %EOL%    float fTemp = fLightScale * fCameraScale; 		%EOL%%EOL%    // Initialize the scattering loop variables %EOL%    float fSampleLength = fFar / atmos_fSamples; 		%EOL%    float fScaledLength = fSampleLength * atmos_fScale; 					%EOL%    vec3 v3SampleRay = v3Ray * fSampleLength; 	%EOL%    vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5; 	%EOL%%EOL%    // Now loop through the sample rays %EOL%    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0); %EOL%    vec3 v3Attenuate = vec3(1,0,0); %EOL%%EOL%    for(int i=0; i<atmos_nSamples; ++i) %EOL%    {         %EOL%        float fHeight = length(v3SamplePoint-earthCenter); 			%EOL%        float fDepth = exp(atmos_fScaleOverScaleDepth * (atmos_fInnerRadius - fHeight)); %EOL%        float fScatter = fDepth*fTemp - fCameraOffset; %EOL%        v3Attenuate = exp(-fScatter * (atmos_v3InvWavelength * atmos_fKr4PI + atmos_fKm4PI)); 	%EOL%        v3FrontColor += v3Attenuate * (fDepth * fScaledLength); 					%EOL%        v3SamplePoint += v3SampleRay; 		%EOL%    } 	%EOL%%EOL%    atmos_color = v3FrontColor * (atmos_v3InvWavelength * atmos_fKrESun + atmos_fKmESun); %EOL%    atmos_atten = v3Attenuate; %EOL%} 		%EOL%%EOL%void atmos_GroundFromAtmosphere(in vec4 vertexVIEW) 		%EOL%{ %EOL%    // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere) %EOL%    vec3 v3Pos = vertexVIEW.xyz / vertexVIEW.w; %EOL%    vec3 v3Ray = v3Pos; %EOL%    float fFar = length(v3Ray); %EOL%    v3Ray /= fFar; %EOL%        %EOL%    vec4 ec4 = osg_ViewMatrix * vec4(0,0,0,1); %EOL%    vec3 earthCenter = ec4.xyz/ec4.w; %EOL%    vec3 normal = normalize(v3Pos-earthCenter); %EOL%    atmos_up = normal; %EOL%%EOL%    // Calculate the ray's starting position, then calculate its scattering offset %EOL%    float fDepth = exp((atmos_fInnerRadius - atmos_fCameraHeight) / atmos_fScaleDepth);%EOL%    float fCameraAngle = max(0.0, dot(-v3Ray, normal)); %EOL%    float fLightAngle = dot(atmos_lightDir, normal); %EOL%    float fCameraScale = atmos_scale(fCameraAngle); %EOL%    float fLightScale = atmos_scale(fLightAngle); %EOL%    float fCameraOffset = fDepth*fCameraScale; %EOL%    float fTemp = fLightScale * fCameraScale; %EOL%%EOL%    // Initialize the scattering loop variables 	%EOL%    float fSampleLength = fFar / atmos_fSamples; 		%EOL%    float fScaledLength = fSampleLength * atmos_fScale; 					%EOL%    vec3 v3SampleRay = v3Ray * fSampleLength; 	%EOL%    vec3 v3SamplePoint = v3SampleRay * 0.5; 	%EOL%%EOL%    // Now loop through the sample rays %EOL%    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0); %EOL%    vec3 v3Attenuate;   %EOL%    for(int i=0; i<atmos_nSamples; i++) 		%EOL%    { %EOL%        float fHeight = length(v3SamplePoint-earthCenter); 			%EOL%        float fDepth = exp(atmos_fScaleOverScaleDepth * (atmos_fInnerRadius - fHeight)); %EOL%        float fScatter = fDepth*fTemp - fCameraOffset; %EOL%        v3Attenuate = exp(-fScatter * (atmos_v3InvWavelength * atmos_fKr4PI + atmos_fKm4PI)); 	%EOL%        v3FrontColor += v3Attenuate * (fDepth * fScaledLength); 					%EOL%        v3SamplePoint += v3SampleRay; 		%EOL%    } 		%EOL%%EOL%    atmos_color = v3FrontColor * (atmos_v3InvWavelength * atmos_fKrESun + atmos_fKmESun); 			%EOL%    atmos_atten = v3Attenuate; %EOL%} %EOL%%EOL%void atmos_vertex_main(inout vec4 vertexVIEW) %EOL%{%EOL%#ifndef OE_LIGHTING%EOL%    return;%EOL%#endif%EOL%%EOL%    atmos_fCameraHeight = length(osg_ViewMatrixInverse[3].xyz); %EOL%    atmos_fCameraHeight2 = atmos_fCameraHeight*atmos_fCameraHeight; %EOL%    atmos_lightDir = normalize(osg_LightSource[0].position.xyz);  // view space%EOL%    atmos_vert = vertexVIEW.xyz; %EOL%%EOL%    atmos_space = max(0.0, (atmos_fCameraHeight-atmos_fInnerRadius)/(atmos_fOuterRadius-atmos_fInnerRadius));%EOL%%EOL%    if(atmos_fCameraHeight >= atmos_fOuterRadius) %EOL%    { %EOL%        atmos_GroundFromSpace(vertexVIEW); %EOL%    } %EOL%    else %EOL%    { %EOL%        atmos_GroundFromAtmosphere(vertexVIEW); %EOL%    } %EOL%}%EOL%%EOL%";

    Ground_ONeil_Frag = "SimpleSky.Ground.ONeil.frag.glsl";
    _sources[Ground_ONeil_Frag] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint atmos_fragment_main%EOL%#pragma vp_location   fragment_lighting%EOL%#pragma vp_order      0.8%EOL%%EOL%#pragma import_defines(OE_LIGHTING)%EOL%#pragma import_defines(OE_NUM_LIGHTS)%EOL%%EOL%uniform float oe_sky_exposure;           // HDR scene exposure (ground level)%EOL%uniform float oe_sky_ambientBoostFactor; // ambient sunlight booster for daytime%EOL%%EOL%in vec3 atmos_lightDir;    // light direction (view coords)%EOL%in vec3 atmos_color;       // atmospheric lighting color%EOL%in vec3 atmos_atten;       // atmospheric lighting attenuation factor%EOL%in vec3 atmos_up;          // earth up vector at fragment (in view coords)%EOL%in float atmos_space;      // camera altitude (0=ground, 1=atmos outer radius)%EOL%in vec3 atmos_vert; %EOL%        %EOL%vec3 vp_Normal;          // surface normal (from osgEarth)%EOL%%EOL%// Parameters of each light:%EOL%struct osg_LightSourceParameters %EOL%{   %EOL%   vec4 ambient;%EOL%   vec4 diffuse;%EOL%   vec4 specular;%EOL%   vec4 position;%EOL%   vec3 spotDirection;%EOL%   float spotExponent;%EOL%   float spotCutoff;%EOL%   float spotCosCutoff;%EOL%   float constantAttenuation;%EOL%   float linearAttenuation;%EOL%   float quadraticAttenuation;%EOL%%EOL%   bool enabled;%EOL%};  %EOL%uniform osg_LightSourceParameters osg_LightSource[OE_NUM_LIGHTS];%EOL%%EOL%// Surface material:%EOL%struct osg_MaterialParameters  %EOL%{   %EOL%   vec4 emission;    // Ecm   %EOL%   vec4 ambient;     // Acm   %EOL%   vec4 diffuse;     // Dcm   %EOL%   vec4 specular;    // Scm   %EOL%   float shininess;  // Srm  %EOL%};  %EOL%uniform osg_MaterialParameters osg_FrontMaterial; %EOL%%EOL%%EOL%void atmos_fragment_main(inout vec4 color) %EOL%{ %EOL%#ifndef OE_LIGHTING%EOL%    return;%EOL%#endif%EOL%%EOL%    // See:%EOL%    // https://en.wikipedia.org/wiki/Phong_reflection_model%EOL%    // https://www.opengl.org/sdk/docs/tutorials/ClockworkCoders/lighting.php%EOL%    // https://en.wikibooks.org/wiki/GLSL_Programming/GLUT/Multiple_Lights%EOL%    // https://en.wikibooks.org/wiki/GLSL_Programming/GLUT/Specular_Highlights%EOL%%EOL%    // normal vector at vertex%EOL%    vec3 N = normalize(vp_Normal);%EOL%%EOL%    float shine = clamp(osg_FrontMaterial.shininess, 1.0, 128.0); %EOL%    vec4 surfaceSpecularity = osg_FrontMaterial.specular;%EOL%    %EOL%    // up vector at vertex%EOL%    vec3 U = normalize(atmos_up);%EOL%%EOL%    // Accumulate the lighting for each component separately.%EOL%    vec3 totalDiffuse = vec3(0.0);%EOL%    vec3 totalAmbient = vec3(0.0);%EOL%    vec3 totalSpecular = vec3(0.0);%EOL%%EOL%    int numLights = OE_NUM_LIGHTS;%EOL%%EOL%    for (int i=0; i<numLights; ++i)%EOL%    {%EOL%        if (osg_LightSource[i].enabled)%EOL%        {%EOL%            float attenuation = 1.0;%EOL%%EOL%            // L is the normalized camera-to-light vector.%EOL%            vec3 L = normalize(osg_LightSource[i].position.xyz);%EOL%%EOL%            // V is the normalized vertex-to-camera vector.%EOL%            vec3 V = -normalize(atmos_vert);%EOL%%EOL%            // point or spot light:%EOL%            if (osg_LightSource[i].position.w != 0.0)%EOL%            {%EOL%                // VLu is the unnormalized vertex-to-light vector%EOL%                vec3 Lu = osg_LightSource[i].position.xyz - atmos_vert;%EOL%%EOL%                // calculate attenuation:%EOL%                float distance = length(Lu);%EOL%                attenuation = 1.0 / (%EOL%                    osg_LightSource[i].constantAttenuation +%EOL%                    osg_LightSource[i].linearAttenuation * distance +%EOL%                    osg_LightSource[i].quadraticAttenuation * distance * distance);%EOL%%EOL%                // for a spot light, the attenuation help form the cone:%EOL%                if (osg_LightSource[i].spotCutoff <= 90.0)%EOL%                {%EOL%                    vec3 D = normalize(osg_LightSource[i].spotDirection);%EOL%                    float clampedCos = max(0.0, dot(-L,D));%EOL%                    attenuation = clampedCos < osg_LightSource[i].spotCosCutoff ?%EOL%                        0.0 :%EOL%                        attenuation * pow(clampedCos, osg_LightSource[i].spotExponent);%EOL%                }%EOL%            }%EOL%%EOL%            // a term indicating whether it's daytime for light 0 (the sun).%EOL%            float dayTerm = i==0? dot(U,L) : 1.0;%EOL%%EOL%            // This term boosts the ambient lighting for the sun (light 0) when it's daytime.%EOL%            // TODO: make the boostFactor a uniform?%EOL%            float ambientBoost = i==0? 1.0 + oe_sky_ambientBoostFactor*clamp(2.0*(dayTerm-0.5), 0.0, 1.0) : 1.0;%EOL%%EOL%            vec3 ambientReflection =%EOL%                attenuation%EOL%                * osg_LightSource[i].ambient.rgb%EOL%                * ambientBoost;%EOL%%EOL%            float NdotL = max(dot(N,L), 0.0);%EOL%%EOL%            // this term, applied to light 0 (the sun), attenuates the diffuse light%EOL%            // during the nighttime, so that geometry doesn't get lit based on its%EOL%            // normals during the night.%EOL%            float diffuseAttenuation = clamp(dayTerm+0.35, 0.0, 1.0);%EOL%            %EOL%            vec3 diffuseReflection =%EOL%                attenuation%EOL%                * diffuseAttenuation%EOL%                * osg_LightSource[i].diffuse.rgb%EOL%                * NdotL;%EOL%                %EOL%            vec3 specularReflection = vec3(0.0);%EOL%            if (NdotL > 0.0)%EOL%            {%EOL%                // prevent a sharp edge where NdotL becomes positive%EOL%                // by fading in the spec between (0.0 and 0.1)%EOL%                float specAttenuation = clamp(NdotL*10.0, 0.0, 1.0);%EOL%%EOL%                vec3 H = reflect(-L,N);%EOL%                float HdotV = max(dot(H,V), 0.0); %EOL%%EOL%                specularReflection =%EOL%                      specAttenuation%EOL%                    * attenuation%EOL%                    * osg_LightSource[i].specular.rgb%EOL%                    * surfaceSpecularity.rgb%EOL%                    * pow(HdotV, shine);%EOL%            }%EOL%%EOL%            totalDiffuse += diffuseReflection;%EOL%            totalAmbient += ambientReflection;%EOL%            totalSpecular += specularReflection;%EOL%        }%EOL%    }%EOL%    %EOL%    // add the atmosphere color, and incorpoate the lights.%EOL%    color.rgb += atmos_color;%EOL%%EOL%    vec3 lightColor =%EOL%        osg_FrontMaterial.emission.rgb +%EOL%        totalDiffuse * osg_FrontMaterial.diffuse.rgb +%EOL%        totalAmbient * osg_FrontMaterial.ambient.rgb;%EOL%%EOL%    color.rgb =%EOL%        color.rgb * lightColor +%EOL%        totalSpecular; // * osg_FrontMaterial.specular.rgb;%EOL%    %EOL%    // Simulate HDR by applying an exposure factor (1.0 is none, 2-3 are reasonable)%EOL%    color.rgb = 1.0 - exp(-oe_sky_exposure * color.rgb);%EOL%}%EOL%%EOL%";

    Moon_Vert = "SimpleSky.Moon.vert.glsl";
    _sources[Moon_Vert] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%uniform vec3 moonToSun;%EOL%out vec4 moon_TexCoord;%EOL%out float moon_Lighting;%EOL%%EOL%void main() %EOL%{ %EOL%    moon_TexCoord = gl_MultiTexCoord0;%EOL%    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; %EOL%%EOL%    // dot product results in a %QUOTE%lighting%QUOTE% factor, 0=none, 1=full,%EOL%    // to send to the fragment shader%EOL%    moon_Lighting = clamp(dot(gl_Normal, moonToSun), 0, 1);%EOL%    moon_Lighting = pow(moon_Lighting, 0.4);%EOL%}%EOL%%EOL%";

    Moon_Frag = "SimpleSky.Moon.frag.glsl";
    _sources[Moon_Frag] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%in vec4 moon_TexCoord;%EOL%in float moon_Lighting;%EOL%uniform sampler2D moonTex;%EOL%%EOL%out vec4 out_FragColor;%EOL%%EOL%void main( void ) %EOL%{ %EOL%    vec4 color = texture(moonTex, moon_TexCoord.st);%EOL%    out_FragColor = vec4(color.rgb*moon_Lighting, color.a);%EOL%}%EOL%%EOL%";

    Stars_Vert = "SimpleSky.Stars.vert.glsl";
    _sources[Stars_Vert] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_Stars_VS%EOL%#pragma vp_location vertex_clip%EOL%%EOL%uniform float oe_GL_PointSize;%EOL%uniform vec3 atmos_v3LightDir; %EOL%uniform mat4 osg_ViewMatrixInverse; %EOL%out float oe_Stars_visibility; %EOL%vec4 vp_Color;%EOL%%EOL%float remap( float val, float vmin, float vmax, float r0, float r1 ) %EOL%{ %EOL%    float vr = (clamp(val, vmin, vmax)-vmin)/(vmax-vmin); %EOL%    return r0 + vr * (r1-r0); %EOL%} %EOL%%EOL%void oe_Stars_VS(inout vec4 vertexClip)%EOL%{ %EOL%    gl_PointSize = vp_Color.r * oe_GL_PointSize;%EOL%    vec3 eye = osg_ViewMatrixInverse[3].xyz; %EOL%    float hae = length(eye) - 6378137.0; %EOL%    // highness: visibility increases with altitude%EOL%    float highness = remap( hae, 25000.0, 150000.0, 0.0, 1.0 ); %EOL%    eye = normalize(eye); %EOL%    // darkness: visibility increase as the sun goes around the other side of the earth%EOL%    float darkness = 1.0-remap(dot(eye, atmos_v3LightDir), -0.25, 0.0, 0.0, 1.0); %EOL%    oe_Stars_visibility = clamp(highness + darkness, 0.0, 1.0); %EOL%%EOL%    // clamp stars to the far clip plane to prevent any flickering or precision%EOL%    // issues based on the extreme distance.%EOL%    vertexClip.z = vertexClip.w;%EOL%}%EOL%%EOL%%EOL%";

    Stars_Frag = "SimpleSky.Stars.frag.glsl";
    _sources[Stars_Frag] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_Stars_FS%EOL%#pragma vp_location fragment_coloring%EOL%%EOL%in float oe_Stars_visibility; %EOL%%EOL%void oe_Stars_FS(inout vec4 color)%EOL%{ %EOL%    float b1 = 1.0-(2.0*abs(gl_PointCoord.s-0.5)); %EOL%    float b2 = 1.0-(2.0*abs(gl_PointCoord.t-0.5)); %EOL%    float i = b1*b1 * b2*b2; %EOL%    color = color * i * oe_Stars_visibility;%EOL%}%EOL%%EOL%";
    
    Stars_GLES_Vert = "SimpleSky.Stars.GLES.vert.glsl";
    _sources[Stars_GLES_Vert] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%uniform vec3 atmos_v3LightDir; %EOL%uniform mat4 osg_ViewMatrixInverse; %EOL%%EOL%out float visibility; %EOL%out vec4 osg_FrontColor; %EOL%%EOL%float remap( float val, float vmin, float vmax, float r0, float r1 ) %EOL%{ %EOL%    float vr = (clamp(val, vmin, vmax)-vmin)/(vmax-vmin); %EOL%    return r0 + vr * (r1-r0); %EOL%} %EOL%%EOL%void main() %EOL%{ %EOL%    osg_FrontColor = gl_Color; %EOL%    gl_PointSize = gl_Color.r * 2.0; %EOL%    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; %EOL%    vec3 eye = osg_ViewMatrixInverse[3].xyz; %EOL%    float hae = length(eye) - 6378137.0; %EOL%    // highness: visibility increases with altitude%EOL%    float highness = remap( hae, 25000.0, 150000.0, 0.0, 1.0 ); %EOL%    eye = normalize(eye); %EOL%    // darkness: visibility increase as the sun goes around the other side of the earth%EOL%    float darkness = 1.0-remap(dot(eye,atmos_v3LightDir), -0.25, 0.0, 0.0, 1.0); %EOL%    visibility = clamp(highness + darkness, 0.0, 1.0); %EOL%}%EOL%%EOL%";

    Stars_GLES_Frag = "SimpleSky.Stars.GLES.frag.glsl";
    _sources[Stars_GLES_Frag] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%in float visibility; %EOL%in vec4 osg_FrontColor; %EOL%%EOL%out vec4 out_FragColor;%EOL%%EOL%void main( void ) %EOL%{ %EOL%    out_FragColor = osg_FrontColor * visibility; %EOL%}%EOL%%EOL%";

    Sun_Vert = "SimpleSky.Sun.vert.glsl";
    _sources[Sun_Vert] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%out vec3 atmos_v3Direction; %EOL%%EOL%void main() %EOL%{ %EOL%    vec3 v3Pos = gl_Vertex.xyz; %EOL%    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; %EOL%    atmos_v3Direction = vec3(0.0,0.0,1.0) - v3Pos; %EOL%    atmos_v3Direction = atmos_v3Direction/length(atmos_v3Direction); %EOL%}%EOL%%EOL%";

    Sun_Frag = "SimpleSky.Sun.frag.glsl";
    _sources[Sun_Frag] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%in vec3 atmos_v3Direction;%EOL%out vec4 out_FragColor;%EOL%%EOL%float atmos_fastpow(in float x, in float y) %EOL%{ %EOL%    return x/(x+y-y*x); %EOL%} %EOL%%EOL%void main( void ) %EOL%{ %EOL%   float fCos = -atmos_v3Direction[2];          %EOL%   float fMiePhase = 0.050387596899224826 * (1.0 + fCos*fCos) / atmos_fastpow(1.9024999999999999 - -1.8999999999999999*fCos, 1.5); %EOL%   out_FragColor.rgb = fMiePhase*vec3(.3,.3,.2);%EOL%   // Alpha needs to scale from full at the center (where red == 1) to 0 on the edges of sun disc%EOL%   out_FragColor.a = out_FragColor.r;%EOL%}%EOL%%EOL%";
}
