// CMake will compile this file into AutoGenShaders.c""

#include <osgEarthSplat/SplatShaders>

//#define MULTILINE(...) #__VA_ARGS__

using namespace osgEarth::Splat;

SplattingShaders::SplattingShaders()
{
    Types = "Splat.types.glsl";
    _sources[Types] = "// begin: Splat.types.glsl%EOL%%EOL%// Environment structure passed around locally.%EOL%struct oe_SplatEnv {%EOL%    float lod;%EOL%    float range;%EOL%    float elevation;%EOL%    float slope;%EOL%    vec4 noise;%EOL%};%EOL%%EOL%// Rendering parameters for splat texture and noise-based detail texture.%EOL%struct oe_SplatRenderInfo {%EOL%    float primaryIndex;%EOL%    float detailIndex;%EOL%    float materialIndex;%EOL%    float brightness;%EOL%    float contrast;%EOL%    float threshold;%EOL%    float minSlope;%EOL%};%EOL%%EOL%// end: Splat.types.glsl%EOL%";

    Noise = "Splat.Noise.glsl";
    _sources[Noise] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%//%EOL%// Description : Array and textureless GLSL 2D/3D/4D simplex %EOL%//               noise functions.%EOL%//      Author : Ian McEwan, Ashima Arts.%EOL%//  Maintainer : ijm%EOL%//     Lastmod : 20110822 (ijm)%EOL%//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.%EOL%//               Distributed under the MIT License. See LICENSE file.%EOL%//               https://github.com/ashima/webgl-noise%EOL%// %EOL%%EOL%vec4 oe_noise_mod289(vec4 x) {%EOL%  return x - floor(x * (1.0 / 289.0)) * 289.0; }%EOL%%EOL%float oe_noise_mod289(float x) {%EOL%  return x - floor(x * (1.0 / 289.0)) * 289.0; }%EOL%%EOL%vec4 oe_noise_permute(vec4 x) {%EOL%     return oe_noise_mod289(((x*34.0)+1.0)*x);%EOL%}%EOL%%EOL%float oe_noise_permute(float x) {%EOL%     return oe_noise_mod289(((x*34.0)+1.0)*x);%EOL%}%EOL%%EOL%vec4 oe_noise_taylorInvSqrt(vec4 r)%EOL%{%EOL%  return 1.79284291400159 - 0.85373472095314 * r;%EOL%}%EOL%%EOL%float oe_noise_taylorInvSqrt(float r)%EOL%{%EOL%  return 1.79284291400159 - 0.85373472095314 * r;%EOL%}%EOL%%EOL%vec4 oe_noise_grad4(float j, vec4 ip)%EOL%  {%EOL%  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);%EOL%  vec4 p,s;%EOL%%EOL%  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;%EOL%  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);%EOL%  s = vec4(lessThan(p, vec4(0.0)));%EOL%  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; %EOL%%EOL%  return p;%EOL%  }%EOL%						%EOL%// (sqrt(5) - 1)/4 = F4, used once below%EOL%#define oe_noise_F4 0.309016994374947451%EOL%%EOL%float oe_noise_snoise(vec4 v)%EOL%  {%EOL%  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4%EOL%                        0.276393202250021,  // 2 * G4%EOL%                        0.414589803375032,  // 3 * G4%EOL%                       -0.447213595499958); // -1 + 4 * G4%EOL%%EOL%// First corner%EOL%  vec4 i  = floor(v + dot(v, vec4(oe_noise_F4)) );%EOL%  vec4 x0 = v -   i + dot(i, C.xxxx);%EOL%%EOL%// Other corners%EOL%%EOL%// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)%EOL%  vec4 i0;%EOL%  vec3 isX = step( x0.yzw, x0.xxx );%EOL%  vec3 isYZ = step( x0.zww, x0.yyz );%EOL%//  i0.x = dot( isX, vec3( 1.0 ) );%EOL%  i0.x = isX.x + isX.y + isX.z;%EOL%  i0.yzw = 1.0 - isX;%EOL%//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );%EOL%  i0.y += isYZ.x + isYZ.y;%EOL%  i0.zw += 1.0 - isYZ.xy;%EOL%  i0.z += isYZ.z;%EOL%  i0.w += 1.0 - isYZ.z;%EOL%%EOL%  // i0 now contains the unique values 0,1,2,3 in each channel%EOL%  vec4 i3 = clamp( i0, 0.0, 1.0 );%EOL%  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );%EOL%  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );%EOL%%EOL%  //  x0 = x0 - 0.0 + 0.0 * C.xxxx%EOL%  //  x1 = x0 - i1  + 1.0 * C.xxxx%EOL%  //  x2 = x0 - i2  + 2.0 * C.xxxx%EOL%  //  x3 = x0 - i3  + 3.0 * C.xxxx%EOL%  //  x4 = x0 - 1.0 + 4.0 * C.xxxx%EOL%  vec4 x1 = x0 - i1 + C.xxxx;%EOL%  vec4 x2 = x0 - i2 + C.yyyy;%EOL%  vec4 x3 = x0 - i3 + C.zzzz;%EOL%  vec4 x4 = x0 + C.wwww;%EOL%%EOL%// Permutations%EOL%  i = oe_noise_mod289(i); %EOL%  float j0 = oe_noise_permute( oe_noise_permute( oe_noise_permute( oe_noise_permute(i.w) + i.z) + i.y) + i.x);%EOL%  vec4 j1 = oe_noise_permute( oe_noise_permute( oe_noise_permute( oe_noise_permute (%EOL%             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))%EOL%           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))%EOL%           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))%EOL%           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));%EOL%%EOL%// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope%EOL%// 7*7*6 = 294, which is close to the ring size 17*17 = 289.%EOL%  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;%EOL%%EOL%  vec4 p0 = oe_noise_grad4(j0,   ip);%EOL%  vec4 p1 = oe_noise_grad4(j1.x, ip);%EOL%  vec4 p2 = oe_noise_grad4(j1.y, ip);%EOL%  vec4 p3 = oe_noise_grad4(j1.z, ip);%EOL%  vec4 p4 = oe_noise_grad4(j1.w, ip);%EOL%%EOL%// Normalise gradients%EOL%  vec4 norm = oe_noise_taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));%EOL%  p0 *= norm.x;%EOL%  p1 *= norm.y;%EOL%  p2 *= norm.z;%EOL%  p3 *= norm.w;%EOL%  p4 *= oe_noise_taylorInvSqrt(dot(p4,p4));%EOL%%EOL%// Mix contributions from the five corners%EOL%  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);%EOL%  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);%EOL%  m0 = m0 * m0;%EOL%  m1 = m1 * m1;%EOL%  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))%EOL%               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;%EOL%}%EOL%%EOL%// Generates a tiled fractal simplex noise value and clamps the values to [0..1].%EOL%float oe_noise_fractal4D(in vec2 seed, in float frequency, in float persistence, in float lacunarity, in int octaves)%EOL%{%EOL%    const float TwoPI = 6.283185;%EOL%	float f = frequency;%EOL%	float amp = 1.0;%EOL%	float maxAmp = 0.0;%EOL%	float n = 0.0;%EOL%    %EOL%    vec4 seed4D;%EOL%    seed4D.xy = cos(seed*TwoPI)/TwoPI;%EOL%    seed4D.zw = sin(seed*TwoPI)/TwoPI;%EOL%%EOL%	for(int i=0; i<octaves; ++i)%EOL%	{%EOL%		n += oe_noise_snoise(seed4D*f) * amp;%EOL%		maxAmp += amp;%EOL%		amp *= persistence;%EOL%		f *= lacunarity;%EOL%	}%EOL%	//return n / maxAmp;%EOL%    const float low = 0.0;%EOL%    const float high = 1.0;%EOL%%EOL%    n /= maxAmp;%EOL%    n = n * (high-low)/2.0 + (high+low)/2.0;%EOL%    return clamp(n, 0.0, 1.0);%EOL%}%EOL%%EOL%";

    VertModel = "Splat.vert.model.glsl";
    _sources[VertModel] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_splat_vertex_model%EOL%#pragma vp_location   vertex_model%EOL%#pragma vp_order      0.5%EOL%#pragma import_defines(OE_TERRAIN_RENDER_NORMAL_MAP)%EOL%%EOL%// Transmit the approximate terrain slope if we're not rendering normal maps%EOL%// in the terrain engine.%EOL%#ifndef OE_TERRAIN_RENDER_NORMAL_MAP%EOL%vec3 vp_Normal; // stage global%EOL%out float oe_splat_slope;%EOL%%EOL%void oe_splat_vertex_model(inout vec4 VertexMODEL)%EOL%{%EOL%    // calculate slope from the Z component of the current normal%EOL%    // since the terrain is in LTP space. This is only used when normal maps%EOL%    // are not available, which is hopefully never :/%EOL%    oe_splat_slope = 1.0-vp_Normal.z;%EOL%}%EOL%%EOL%#else%EOL%%EOL%void oe_splat_vertex_model(inout vec4 VertexMODEL)%EOL%{%EOL%    //nop%EOL%}%EOL%%EOL%#endif%EOL%%EOL%";

    VertView = "Splat.vert.view.glsl";
    _sources[VertView] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_splat_vertex_view%EOL%#pragma vp_location   vertex_view%EOL%%EOL%#pragma include Splat.types.glsl%EOL%%EOL%#pragma import_defines(OE_LANDCOVER_TEX)%EOL%#pragma import_defines(OE_LANDCOVER_TEX_MATRIX)%EOL%%EOL%out vec4 oe_layer_tilec;%EOL%out float oe_splat_range;%EOL%out vec2 oe_splat_covtc;%EOL%%EOL%uniform sampler2D OE_LANDCOVER_TEX;%EOL%uniform mat4 OE_LANDCOVER_TEX_MATRIX;%EOL%%EOL%flat out float oe_splat_coverageTexSize;%EOL%%EOL%//uniform mat4 OE_SPLAT_COVERAGE_TEXMAT;   // assigned at runtime%EOL%%EOL%uniform vec3 oe_Camera; // (vp width, vp height, LOD scale)%EOL%%EOL%%EOL%void oe_splat_vertex_view(inout vec4 VertexVIEW)%EOL%{%EOL%    // range from camera to vertex%EOL%    oe_splat_range = -VertexVIEW.z * oe_Camera.z; // apply LOD scale%EOL%%EOL%    // calculate the coverage sampling coordinates. The texture matrix accounts%EOL%    // for any super-sampling that might be in effect for the current LOD.%EOL%    oe_splat_covtc = (OE_LANDCOVER_TEX_MATRIX * oe_layer_tilec).st;%EOL%%EOL%    // Precalculate the size of the coverage texture. This is faster than%EOL%    // calling textureSize per pixel in the fragment shader.%EOL%    oe_splat_coverageTexSize = textureSize(OE_LANDCOVER_TEX, 0).x;%EOL%}%EOL%%EOL%";

    Frag = "Splat.frag.glsl";
    _sources[Frag] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#if(__VERSION__ < 400)%EOL%    #extension GL_ARB_gpu_shader5 : enable  // textureGather%EOL%#endif%EOL%%EOL%#pragma vp_entryPoint oe_splat_sampleCoverage%EOL%#pragma vp_location   fragment_coloring%EOL%#pragma vp_order      0.2%EOL%%EOL%#pragma import_defines(OE_LANDCOVER_TEX);%EOL%%EOL%uniform sampler2D OE_LANDCOVER_TEX;%EOL%%EOL%//uniform sampler2D oe_splat_coverageTex;%EOL%in vec2 oe_splat_covtc;%EOL%flat in float oe_splat_coverageTexSize;%EOL%%EOL%// stage global: set this and read it in the splatter.%EOL%vec4 oe_LandCover_coverage;%EOL%%EOL%// read the comment below regarding textureGather%EOL%//#define USE_TEXTURE_GATHER%EOL%%EOL%void oe_splat_sampleCoverage(inout vec4 unused)%EOL%{%EOL%#ifdef USE_TEXTURE_GATHER%EOL%    // A wee bit faster, but causes a rendering anomaly%EOL%    oe_splat_coverage = textureGather(oe_tile_landCoverTex, oe_splat_covtc, 0).wzxy;%EOL%#else%EOL%%EOL%    float pixelWidth = 1.0/oe_splat_coverageTexSize;%EOL%    float halfPixelWidth = pixelWidth * 0.5;%EOL%%EOL%    // Find the four quantized coverage coordinates that form a box around the actual%EOL%    // coverage coordinates, where each quantized coord is at the center of a coverage texel.%EOL%    vec2 rem = mod(oe_splat_covtc, pixelWidth);%EOL%    vec2 sw;%EOL%    sw.x = oe_splat_covtc.x - rem.x + (rem.x >= halfPixelWidth ? halfPixelWidth : -halfPixelWidth);%EOL%    sw.y = oe_splat_covtc.y - rem.y + (rem.y >= halfPixelWidth ? halfPixelWidth : -halfPixelWidth); %EOL%    vec2 ne = sw + pixelWidth;%EOL%    vec2 nw = vec2(sw.x, ne.y);%EOL%    vec2 se = vec2(ne.x, sw.y);%EOL%%EOL%    oe_LandCover_coverage = vec4(%EOL%        texture(OE_LANDCOVER_TEX, sw).r,%EOL%        texture(OE_LANDCOVER_TEX, se).r,%EOL%        texture(OE_LANDCOVER_TEX, nw).r,%EOL%        texture(OE_LANDCOVER_TEX, ne).r );%EOL%%EOL%    //return vec4(%EOL%    //    texture(oe_splat_coverageTex, clamp(sw, 0.0, 1.0)).r,%EOL%    //    texture(oe_splat_coverageTex, clamp(se, 0.0, 1.0)).r,%EOL%    //    texture(oe_splat_coverageTex, clamp(nw, 0.0, 1.0)).r,%EOL%    //    texture(oe_splat_coverageTex, clamp(ne, 0.0, 1.0)).r );%EOL%#endif%EOL%}%EOL%%EOL%%EOL%%EOL%[break]%EOL%%EOL%%EOL%    %EOL%#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%// order of 1.1 allows user the opportunity to override oe_splat_coverage stage global%EOL%#pragma vp_entryPoint oe_splat_complex%EOL%#pragma vp_location   fragment_coloring%EOL%#pragma vp_order      1.1%EOL%%EOL%// include files%EOL%#pragma include Splat.types.glsl%EOL%%EOL%// statset defines%EOL%#pragma import_defines(OE_SPLAT_NOISE_SAMPLER)%EOL%#pragma import_defines(OE_SPLAT_EDIT_MODE)%EOL%#pragma import_defines(OE_SPLAT_GPU_NOISE)%EOL%#pragma import_defines(OE_TERRAIN_RENDER_NORMAL_MAP)%EOL%#pragma import_defines(OE_TERRAIN_BLEND_IMAGERY)%EOL%#pragma import_defines(OE_SPLAT_USE_MATERIALS)%EOL%%EOL%// from: Splat.util.glsl%EOL%void oe_splat_getLodBlend(in float range, out float lod0, out float rangeOuter, out float rangeInner, out float clampedRange);%EOL%%EOL%// from terrain SDK:%EOL%vec2 oe_terrain_scaleCoordsToRefLOD(in vec2 tc, in float refLOD);%EOL%%EOL%// from the terrain engine:%EOL%in vec4 oe_layer_tilec;                     // unit tile coords%EOL%%EOL%// from the vertex shader:%EOL%in vec2 oe_splat_covtc;                     // coverage texture coords%EOL%in float oe_splat_range;                    // distance from camera to vertex%EOL%flat in float oe_splat_coverageTexSize;     // size of coverage texture%EOL%%EOL%in float oe_layer_opacity;%EOL%%EOL%// stage global: coverage quad-value set in oe_splat_sampleCoverage%EOL%vec4 oe_LandCover_coverage;%EOL%%EOL%// from SplatLayerFactory:%EOL%uniform sampler2DArray oe_splatTex;%EOL%uniform int oe_splat_scaleOffsetInt;%EOL%%EOL%uniform float oe_splat_detailRange;%EOL%uniform float oe_splat_noiseScale;%EOL%%EOL%#ifdef OE_SPLAT_EDIT_MODE%EOL%uniform float oe_splat_brightness;%EOL%uniform float oe_splat_contrast;%EOL%uniform float oe_splat_threshold;%EOL%uniform float oe_splat_minSlope;%EOL%#endif%EOL%%EOL%// lookup table containing the coverage value => texture index mappings%EOL%uniform samplerBuffer oe_splat_coverageLUT;%EOL%%EOL%uniform int oe_layer_order;%EOL%%EOL%//............................................................................%EOL%// Get the slope of the terrain%EOL%%EOL%#ifdef OE_TERRAIN_RENDER_NORMAL_MAP%EOL%// import SDK%EOL%vec4 oe_terrain_getNormalAndCurvature(in vec2);%EOL%%EOL%// normal map version:%EOL%in vec2 oe_normalMapCoords;%EOL%%EOL%float oe_splat_getSlope()%EOL%{%EOL%    vec4 encodedNormal = oe_terrain_getNormalAndCurvature( oe_normalMapCoords );%EOL%    vec3 normalTangent = normalize(encodedNormal.xyz*2.0-1.0);%EOL%    return clamp((1.0-normalTangent.z)/0.8, 0.0, 1.0);%EOL%}%EOL%%EOL%#else // !OE_TERRAIN_RENDER_NORMAL_MAP%EOL%%EOL%// non- normal map version:%EOL%in float oe_splat_slope;%EOL%%EOL%float oe_splat_getSlope()%EOL%{%EOL%    return oe_splat_slope;%EOL%}%EOL%%EOL%#endif // OE_TERRAIN_RENDER_NORMAL_MAP%EOL%%EOL%%EOL%//............................................................................%EOL%// reads the encoded splatting render information for a coverage value.%EOL%// this data was encoded in Surface::createLUTBUffer().%EOL%%EOL%void oe_splat_getRenderInfo(in float value, in oe_SplatEnv env, out oe_SplatRenderInfo ri)%EOL%{%EOL%    const int num_lods = 26;%EOL%%EOL%    int lutIndex = int(value)*num_lods + int(env.lod);%EOL%%EOL%    // fetch the splatting parameters:%EOL%    vec4 t = texelFetch(oe_splat_coverageLUT, lutIndex);%EOL%%EOL%    ri.primaryIndex = float((int(t[0])>>8)-1);%EOL%    ri.detailIndex  = float((int(t[0])&0xFF)-1);%EOL%%EOL%#ifdef OE_SPLAT_USE_MATERIALS%EOL%    ri.materialIndex = float(int(t[1])-1);%EOL%#endif%EOL%%EOL%    // brightness and contrast are packed into one float:%EOL%    ri.brightness   = trunc(t[2])/100.0;%EOL%    ri.contrast     = fract(t[2])*10.0;%EOL%%EOL%    // threshold and slope are packed into one float:%EOL%    ri.threshold    = trunc(t[3])/100.0;%EOL%    ri.minSlope     = fract(t[3])*10.0;%EOL%}%EOL%%EOL%%EOL%//............................................................................%EOL%// Sample a texel from the splatting texture catalog%EOL%%EOL%void oe_splat_getTexel(in float index, in vec2 tc, out vec4 texel)%EOL%{%EOL%    texel = index >= 0.0 ? texture(oe_splatTex, vec3(tc, index)) : vec4(1,0,0,0);%EOL%}%EOL%%EOL%#ifdef OE_SPLAT_USE_MATERIALS%EOL%void oe_splat_getMaterial(in float index, in vec2 tc, out vec4 material)%EOL%{%EOL%    material = index >= 0.0 ? texture(oe_splatTex, vec3(tc, index)) : vec4(.5,.5,1,0);%EOL%}%EOL%#endif%EOL%%EOL%//............................................................................%EOL%// Samples a detail texel using its render info parameters.%EOL%// Returns the weighting factor in the alpha channel.%EOL%%EOL%vec4 oe_splat_getDetailTexel(in oe_SplatRenderInfo ri, in vec2 tc, in oe_SplatEnv env)%EOL%{%EOL%    float hasDetail = clamp(ri.detailIndex+1.0, 0.0, 1.0);%EOL%%EOL%#ifdef OE_SPLAT_EDIT_MODE%EOL%    float brightness = oe_splat_brightness;%EOL%    float contrast = oe_splat_contrast;%EOL%    float threshold = oe_splat_threshold;%EOL%    float minSlope = oe_splat_minSlope;%EOL%#else%EOL%    float brightness = ri.brightness;%EOL%    float contrast = ri.contrast;%EOL%    float threshold = ri.threshold;%EOL%    float minSlope = ri.minSlope;%EOL%#endif%EOL%%EOL%    // start with the noise value%EOL%    float n = env.noise.x;%EOL%	%EOL%    // apply slope limiter, then reclamp and threshold:%EOL%    float s;%EOL%    if ( env.slope >= minSlope )%EOL%        s = 1.0;%EOL%    else if ( env.slope < 0.1*minSlope )%EOL%        s = 0.0;%EOL%    else%EOL%        s = (env.slope-0.1*minSlope)/(minSlope-0.1*minSlope);%EOL%%EOL%    brightness *= s;%EOL%%EOL%    // apply brightness and contrast, then reclamp%EOL%    n = clamp(((n-0.5)*contrast + 0.5) * brightness, 0.0, 1.0);%EOL%    %EOL%    // apply final threshold:%EOL%	n = n < threshold ? 0.0 : n;%EOL%%EOL%    // sample the texel and return it.%EOL%    vec4 result;%EOL%    oe_splat_getTexel(ri.detailIndex, tc, result);%EOL%    return vec4(result.rgb, hasDetail*n);%EOL%}%EOL%%EOL%//............................................................................%EOL%// Generates a texel using nearest-neighbor coverage sampling.%EOL%%EOL%vec4 oe_splat_nearest(in vec2 splat_tc, in oe_SplatEnv env)%EOL%{%EOL%    float coverageValue = oe_LandCover_coverage[0];%EOL%    oe_SplatRenderInfo ri;%EOL%    oe_splat_getRenderInfo(coverageValue, env, ri);%EOL%    vec4 primary;%EOL%    oe_splat_getTexel(ri.primaryIndex, splat_tc, primary);%EOL%    float detailToggle = ri.detailIndex >= 0 ? 1.0 : 0.0;%EOL%    vec4 detail  = oe_splat_getDetailTexel(ri, splat_tc, env) * detailToggle;    %EOL%    return vec4( mix(primary.rgb, detail.rgb, detail.a), primary.a );%EOL%}%EOL%%EOL%//............................................................................%EOL%// Generates a texel using bilinear filtering on the coverage data.%EOL%%EOL%void oe_splat_bilinear(in vec2 splat_tc, in oe_SplatEnv env, out vec4 color, out vec4 material)%EOL%{%EOL%    // Build the render info data for each corner:%EOL%    oe_SplatRenderInfo ri[4]; //sw,se,nw,ne%EOL%    oe_splat_getRenderInfo(oe_LandCover_coverage[0], env, ri[0]);%EOL%    oe_splat_getRenderInfo(oe_LandCover_coverage[1], env, ri[1]);%EOL%    oe_splat_getRenderInfo(oe_LandCover_coverage[2], env, ri[2]);%EOL%    oe_splat_getRenderInfo(oe_LandCover_coverage[3], env, ri[3]);%EOL%%EOL%    // Primary splat:%EOL%    vec4 p[4];%EOL%    oe_splat_getTexel(ri[0].primaryIndex, splat_tc, p[0]);%EOL%    oe_splat_getTexel(ri[1].primaryIndex, splat_tc, p[1]);%EOL%    oe_splat_getTexel(ri[2].primaryIndex, splat_tc, p[2]);%EOL%    oe_splat_getTexel(ri[3].primaryIndex, splat_tc, p[3]);%EOL%%EOL%#ifdef OE_SPLAT_USE_MATERIALS%EOL%    // Material splat:%EOL%    vec4 m[4];%EOL%    oe_splat_getTexel(ri[0].materialIndex, splat_tc, m[0]);%EOL%    oe_splat_getTexel(ri[1].materialIndex, splat_tc, m[1]);%EOL%    oe_splat_getTexel(ri[2].materialIndex, splat_tc, m[2]);%EOL%    oe_splat_getTexel(ri[3].materialIndex, splat_tc, m[3]);%EOL%#endif%EOL%%EOL%    // Detail splat - weighting is in the alpha channel%EOL%    // TODO: Pointless to have a detail range? -gw%EOL%    // TODO: If noise is a texture, just try to single-sample it instead%EOL%    float dTog = env.range < oe_splat_detailRange ? 1.0 : 0.0;%EOL%    vec4 d[4];%EOL%    d[0] = dTog * oe_splat_getDetailTexel(ri[0], splat_tc, env);%EOL%    d[1] = dTog * oe_splat_getDetailTexel(ri[1], splat_tc, env);%EOL%    d[2] = dTog * oe_splat_getDetailTexel(ri[2], splat_tc, env);%EOL%    d[3] = dTog * oe_splat_getDetailTexel(ri[3], splat_tc, env); %EOL%%EOL%    vec4 b[4];%EOL%    b[0] = vec4(mix(p[0].rgb, d[0].rgb, d[0].a), p[0].a);%EOL%    b[1] = vec4(mix(p[1].rgb, d[1].rgb, d[1].a), p[1].a);%EOL%    b[2] = vec4(mix(p[2].rgb, d[2].rgb, d[2].a), p[2].a);%EOL%    b[3] = vec4(mix(p[3].rgb, d[3].rgb, d[3].a), p[3].a);%EOL%%EOL%    vec2 weight = fract(oe_splat_covtc*oe_splat_coverageTexSize - 0.5);%EOL%%EOL%    vec4 south = mix(b[0], b[1], weight.x);%EOL%    vec4 north = mix(b[2], b[3], weight.x);%EOL%%EOL%    color = mix(south, north, weight.y);%EOL%%EOL%#ifdef OE_SPLAT_USE_MATERIALS%EOL%    south = mix(m[0], m[1], weight.x);%EOL%    north = mix(m[2], m[3], weight.x);%EOL%    material = mix(south, north, weight.y);%EOL%#endif%EOL%}%EOL%%EOL%//............................................................................%EOL%%EOL%#ifdef OE_SPLAT_GPU_NOISE%EOL%%EOL%uniform float oe_splat_freq;%EOL%uniform float oe_splat_pers;%EOL%uniform float oe_splat_lac;%EOL%uniform float oe_splat_octaves;%EOL%%EOL%// see: Splat.Noise.glsl%EOL%float oe_noise_fractal4D(in vec2 seed, in float frequency, in float persistence, in float lacunarity, in int octaves);%EOL%%EOL%vec4 oe_splat_getNoise(in vec2 tc)%EOL%{%EOL%    return vec4(oe_noise_fractal4D(tc, oe_splat_freq, oe_splat_pers, oe_splat_lac, int(oe_splat_octaves)));%EOL%}%EOL%%EOL%#else // !SPLAT_GPU_NOISE%EOL%%EOL%#ifdef OE_SPLAT_NOISE_SAMPLER%EOL%uniform sampler2D OE_SPLAT_NOISE_SAMPLER;%EOL%vec4 oe_splat_getNoise(in vec2 tc)%EOL%{%EOL%    return texture(OE_SPLAT_NOISE_SAMPLER, tc.st);%EOL%}%EOL%#else%EOL%vec4 oe_splat_getNoise(in vec2 tc)%EOL%{%EOL%    return vec4(0.0);%EOL%}%EOL%#endif%EOL%%EOL%#endif // SPLAT_GPU_NOISE%EOL%%EOL%%EOL%%EOL%//............................................................................%EOL%// Simplified entry point with does no filtering or range blending. (much faster.)%EOL%%EOL%void oe_splat_simple(inout vec4 color)%EOL%{%EOL%    float noiseLOD = floor(oe_splat_noiseScale);%EOL%    vec2 noiseCoords = oe_terrain_scaleCoordsToRefLOD(oe_layer_tilec.st, noiseLOD);%EOL%%EOL%    oe_SplatEnv env;%EOL%    env.range = oe_splat_range;%EOL%    env.slope = oe_splat_getSlope();%EOL%    env.noise = oe_splat_getNoise(noiseCoords);%EOL%    env.elevation = 0.0;%EOL%    %EOL%    float lod0;%EOL%    float rangeOuter, rangeInner;%EOL%    oe_splat_getLodBlend(oe_splat_range, lod0, rangeOuter, rangeInner, env.range);%EOL%    vec2 tc = oe_terrain_scaleCoordsToRefLOD(oe_layer_tilec.st, lod0 + float(oe_splat_scaleOffsetInt));%EOL%%EOL%#ifdef OE_SPLAT_USE_MATERIALS%EOL%    vec4 material;%EOL%    oe_splat_bilinear(tc, env, color, material);%EOL%#endif%EOL%%EOL%    color.a *= oe_layer_opacity;%EOL%}%EOL%%EOL%//............................................................................%EOL%// Main entry point for fragment shader.%EOL%%EOL%// stage global%EOL%mat3 oe_normalMapTBN;%EOL%vec3 vp_Normal;%EOL%%EOL%void oe_splat_complex(inout vec4 color)%EOL%{%EOL%    // Noise coords.%EOL%    float noiseLOD = floor(oe_splat_noiseScale);%EOL%    vec2 noiseCoords = oe_terrain_scaleCoordsToRefLOD(oe_layer_tilec.st, noiseLOD); //TODO: move to VS for slight speedup%EOL%%EOL%    oe_SplatEnv env;%EOL%    env.range = oe_splat_range;%EOL%    env.slope = oe_splat_getSlope();%EOL%    env.noise = oe_splat_getNoise(noiseCoords);%EOL%    env.elevation = 0.0;%EOL%%EOL%    // quantize the scale offset so we take the hit in the FS%EOL%    float scaleOffset = float(oe_splat_scaleOffsetInt);%EOL%        %EOL%    // Calculate the 2 LODs we need to blend. We have to do this in the FS because %EOL%    // it's quite possible for a single triangle to span more than 2 LODs.%EOL%    float lod0, lod1;%EOL%    float rangeOuter, rangeInner;%EOL%    oe_splat_getLodBlend(oe_splat_range, lod0, rangeOuter, rangeInner, env.range);%EOL%    %EOL%    // Sample the two LODs:%EOL%    vec4 texel0, texel1;%EOL%    vec4 material0, material1;%EOL%%EOL%    vec2 tc0 = oe_terrain_scaleCoordsToRefLOD(oe_layer_tilec.st, lod0 + scaleOffset);%EOL%    env.lod = lod0;%EOL%    oe_splat_bilinear(tc0, env, texel0, material0);%EOL%    %EOL%    vec2 tc1 = oe_terrain_scaleCoordsToRefLOD(oe_layer_tilec.st, lod0 + 1.0 + scaleOffset);%EOL%    env.lod = lod0+1.0;%EOL%    oe_splat_bilinear(tc1, env, texel1, material1);%EOL%%EOL%    // recalcluate blending ratio%EOL%    float lodBlend = clamp((rangeOuter - env.range) / (rangeOuter - rangeInner), 0, 1);%EOL%       %EOL%    // Blend the two samples based on LOD factor:%EOL%    vec4 texel = mix(texel0, texel1, lodBlend);%EOL%%EOL%#ifdef OE_SPLAT_USE_MATERIALS%EOL%    // Blend together the material samples:%EOL%    vec4 material = mix(material0, material1, lodBlend);%EOL%    vec3 n = oe_normalMapTBN * (material.xyz*2.0-1.0);%EOL%    vp_Normal = normalize(vp_Normal + n);%EOL%#endif%EOL%%EOL%    // incorporate the layer's opacity:%EOL%    texel.a *= oe_layer_opacity;%EOL%%EOL%#ifdef OE_TERRAIN_BLEND_IMAGERY%EOL%    // If this is a first image layer, blend with the incoming terrain color.%EOL%    // Otherwise, apply directly and let GL blending do the rest.%EOL%    if (oe_layer_order == 0)%EOL%    {%EOL%        color.rgb = texel.rgb*texel.a + color.rgb*(1.0-texel.a);%EOL%    }%EOL%    else%EOL%    {%EOL%        color = texel;%EOL%    }%EOL%#else%EOL%    // No blending? The output is just the texel value.%EOL%    color = texel;%EOL%#endif // OE_TERRAIN_BLEND_IMAGERY%EOL%}%EOL%%EOL%";

    Util = "Splat.util.glsl";
    _sources[Util] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_location fragment_coloring%EOL%%EOL%// Number of LOD range. Do not increase this past 25; doing so will result in precision errors%EOL%// and rendering artifacts when the camera is very close to the ground.%EOL%#define LOD_COUNT 26%EOL%%EOL%const float oe_SplatRanges[26] = float[](%EOL%       100000000.0, // 0%EOL%        75000000.0, // 1%EOL%        50000000.0, // 2%EOL%        10000000.0, // 3%EOL%         7500000.0, // 4%EOL%         5000000.0, // 5%EOL%         2500000.0, // 6%EOL%         1000000.0, // 7%EOL%          500000.0, // 8%EOL%          225000.0, // 9%EOL%          150000.0, // 10%EOL%           80000.0, // 11%EOL%           30000.0, // 12%EOL%           14000.0, // 13%EOL%            4000.0, // 14%EOL%            2500.0, // 15%EOL%            1000.0, // 16%EOL%             500.0, // 17%EOL%             250.0, // 18%EOL%             125.0, // 19%EOL%              50.0, // 20%EOL%              25.0, // 21%EOL%              12.0, // 22%EOL%               6.0, // 23%EOL%               3.0, // 24%EOL%               1.0  // 25%EOL%    );%EOL%%EOL%/**%EOL% * Given a camera distance, return the two LODs it falls between and%EOL% * the blend factor [0..1] between then.%EOL% * in  range   = camera distace to fragment%EOL% * in  baseLOD = LOD at which texture scale is 1.0%EOL% * out LOD0    = near LOD%EOL% * out LOD1    = far LOD%EOL% * out blend   = Blend factor between LOD0 and LOD1 [0..1]%EOL% */%EOL%void%EOL%oe_splat_getLodBlend(in float range, out float out_LOD0, out float out_rangeOuter, out float out_rangeInner, out float out_clampedRange)%EOL%{%EOL%    out_clampedRange = clamp(range, oe_SplatRanges[LOD_COUNT-1], oe_SplatRanges[0]);%EOL%%EOL%    out_LOD0 = 0;%EOL%%EOL%    for(int i=0; i<LOD_COUNT-1; ++i)%EOL%    {%EOL%        if ( out_clampedRange < oe_SplatRanges[i] && out_clampedRange >= oe_SplatRanges[i+1] )%EOL%        {%EOL%            out_LOD0 = float(i); //   + baseLOD;%EOL%            break;%EOL%        }%EOL%    }%EOL%%EOL%    out_rangeOuter = oe_SplatRanges[int(out_LOD0)];%EOL%    out_rangeInner = oe_SplatRanges[int(out_LOD0)+1];%EOL%}%EOL%%EOL%";
}


GroundCoverShaders::GroundCoverShaders()
{
    Grass_VS = "Grass.VS.glsl";
    _sources[Grass_VS] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_name       GroundCover vertex shader%EOL%#pragma vp_entryPoint oe_Grass_VS%EOL%#pragma vp_location   vertex_view%EOL%%EOL%#pragma import_defines(OE_GROUNDCOVER_USE_INSTANCING)%EOL%#pragma import_defines(OE_LANDCOVER_TEX)%EOL%#pragma import_defines(OE_LANDCOVER_TEX_MATRIX)%EOL%#pragma import_defines(OE_GROUNDCOVER_MASK_SAMPLER)%EOL%#pragma import_defines(OE_GROUNDCOVER_MASK_MATRIX)%EOL%%EOL%%EOL%#pragma import_defines(OE_GROUNDCOVER_COLOR_SAMPLER)%EOL%#pragma import_defines(OE_GROUNDCOVER_COLOR_MATRIX)%EOL%#ifdef OE_GROUNDCOVER_COLOR_SAMPLER%EOL%uniform sampler2D OE_GROUNDCOVER_COLOR_SAMPLER ;%EOL%uniform mat4 OE_GROUNDCOVER_COLOR_MATRIX ;%EOL%#endif%EOL%%EOL%//uncomment to activate%EOL%//#define OE_GROUNDCOVER_USE_ACTOR%EOL%%EOL%uniform vec2 oe_GroundCover_numInstances;%EOL%uniform vec3 oe_GroundCover_LL, oe_GroundCover_UR;%EOL%%EOL%// Noise texture:%EOL%uniform sampler2D oe_GroundCover_noiseTex;%EOL%vec4 oe_noise;%EOL%// Noise texture channels:%EOL%#define NOISE_SMOOTH   0%EOL%#define NOISE_RANDOM   1%EOL%#define NOISE_RANDOM_2 2%EOL%#define NOISE_CLUMPY   3%EOL%%EOL%// LandCover texture%EOL%uniform sampler2D OE_LANDCOVER_TEX;%EOL%uniform mat4 OE_LANDCOVER_TEX_MATRIX;%EOL%float oe_LandCover_coverage;%EOL%%EOL%vec3 vp_Normal;%EOL%vec4 vp_Color;%EOL%vec4 oe_layer_tilec;%EOL%vec3 oe_UpVectorView;%EOL%%EOL%uniform float osg_FrameTime; // OSG frame time (seconds) used for wind animation%EOL%uniform float oe_GroundCover_wind;  // wind strength%EOL%uniform float oe_GroundCover_maxDistance; // distance at which flora disappears%EOL%%EOL%#ifdef OE_GROUNDCOVER_USE_ACTOR%EOL%uniform float actorRadius;%EOL%uniform float actorHeight;%EOL%//uniform float actorPlace;%EOL%uniform vec3 actorPos;%EOL%uniform mat4 osg_ViewMatrix;%EOL%#endif%EOL%%EOL%uniform vec3 oe_Camera; // (vp width, vp height, LOD scale)%EOL%%EOL%%EOL%                        // Output grass texture coords to the FS%EOL%out vec2 oe_GroundCover_texCoord;%EOL%%EOL%// Output that selects the land cover texture from the texture array (flat)%EOL%flat out float oe_GroundCover_atlasIndex;%EOL%%EOL%struct oe_GroundCover_Biome {%EOL%    int firstObjectIndex;%EOL%    int numObjects;%EOL%    float density;%EOL%    float fill;%EOL%    vec2 maxWidthHeight;%EOL%};%EOL%void oe_GroundCover_getBiome(in int index, out oe_GroundCover_Biome biome);%EOL%%EOL%struct oe_GroundCover_Object {%EOL%    int type;             // 0=billboard %EOL%    int objectArrayIndex; // index into the typed object array %EOL%};%EOL%void oe_GroundCover_getObject(in int index, out oe_GroundCover_Object object);%EOL%%EOL%struct oe_GroundCover_Billboard {%EOL%    int atlasIndexSide;%EOL%    int atlasIndexTop;%EOL%    float width;%EOL%    float height;%EOL%    float sizeVariation;%EOL%};%EOL%void oe_GroundCover_getBillboard(in int index, out oe_GroundCover_Billboard bb);%EOL%%EOL%// SDK import%EOL%float oe_terrain_getElevation(in vec2);%EOL%%EOL%// Generated in GroundCover.cpp%EOL%int oe_GroundCover_getBiomeIndex(in vec4);%EOL%%EOL%#ifdef OE_GROUNDCOVER_MASK_SAMPLER%EOL%uniform sampler2D OE_GROUNDCOVER_MASK_SAMPLER;%EOL%uniform mat4 OE_GROUNDCOVER_MASK_MATRIX;%EOL%#endif%EOL%%EOL%// https://stackoverflow.com/a/17897228/4218920%EOL%vec3 rgb2hsv(vec3 c)%EOL%{%EOL%    const vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);%EOL%    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));%EOL%    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));%EOL%    float d = q.x - min(q.w, q.y);%EOL%    const float e = 1.0e-10;%EOL%    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);%EOL%}%EOL%%EOL%const float oe_grass_hue = 80.0; // HSL hue value%EOL%const float oe_grass_hueWidth = 0.27;%EOL%const float oe_grass_saturation = 0.32;%EOL%%EOL%float accel(float x) {%EOL%    return x*x;%EOL%}%EOL%float decel(float x) {%EOL%    return 1.0-(1.0-x)*(1.0-x);%EOL%}%EOL%%EOL%void oe_Grass_VS(inout vec4 vertex)%EOL%{%EOL%    // intialize with a %QUOTE%no draw%QUOTE% value:%EOL%    oe_GroundCover_atlasIndex = -1.0;%EOL%%EOL%    // input: 8 verts per instance so we can expand into a dual billboard%EOL%#ifdef OE_GROUNDCOVER_USE_INSTANCING%EOL%    int instanceID = gl_InstanceID;%EOL%#else%EOL%    int instanceID = gl_VertexID / 16;%EOL%#endif%EOL%%EOL%    // Generate the UV tile coordinates (oe_layer_tilec) based on the current instance number%EOL%    vec2 numInstances = oe_GroundCover_numInstances;%EOL%%EOL%    vec2 offset = vec2(%EOL%        float(instanceID % int(numInstances.x)),%EOL%        float(instanceID / int(numInstances.y)));%EOL%%EOL%    // half the distance between cell centers%EOL%    vec2 halfSpacing = 0.5/numInstances;%EOL%%EOL%    oe_layer_tilec = vec4( halfSpacing + offset/numInstances, 0, 1);%EOL%%EOL%    // Sample our noise texture%EOL%    oe_noise = textureLod(oe_GroundCover_noiseTex, oe_layer_tilec.st, 0);%EOL%%EOL%    // randomly shift each point off center%EOL%    vec2 shift = vec2(fract(oe_noise[NOISE_RANDOM]*5.5), fract(oe_noise[NOISE_RANDOM_2]*5.5))*2-1;%EOL%    oe_layer_tilec.st += shift*halfSpacing;%EOL%%EOL%    // interpolate to correct position within the tile%EOL%    vertex.xyz +=%EOL%        gl_NormalMatrix *  // model to view%EOL%        vec3(mix(oe_GroundCover_LL.xy, oe_GroundCover_UR.xy, oe_layer_tilec.st), 0);%EOL%%EOL%    // Sample the landcover data. Must do this BEFORE calling getBiomeIndex.%EOL%    oe_LandCover_coverage = textureLod(OE_LANDCOVER_TEX, (OE_LANDCOVER_TEX_MATRIX*oe_layer_tilec).st, 0).r;%EOL%%EOL%    // Look up the biome and bail if not defined%EOL%    int biomeIndex = oe_GroundCover_getBiomeIndex(oe_layer_tilec);%EOL%    if ( biomeIndex < 0 )%EOL%        return;%EOL%%EOL%    // Sample optional mask texture%EOL%#ifdef OE_GROUNDCOVER_MASK_SAMPLER%EOL%    float mask = texture(OE_GROUNDCOVER_MASK_SAMPLER, (OE_GROUNDCOVER_MASK_MATRIX*oe_layer_tilec).st).a;%EOL%    if ( mask > 0.0 )%EOL%        return;%EOL%#endif%EOL%%EOL%    // Clamp the center point to the elevation.%EOL%    vertex.xyz += oe_UpVectorView * oe_terrain_getElevation(oe_layer_tilec.st);%EOL%%EOL%    // Calculate the normalized camera range (oe_Camera.z = LOD Scale)%EOL%    float maxRange = oe_GroundCover_maxDistance / oe_Camera.z;%EOL%    float zv = vertex.z;%EOL%    float nRange = clamp(-zv/maxRange, 0.0, 1.0);%EOL%%EOL%    // Distance culling:%EOL%    if ( nRange == 1.0 )%EOL%        return;%EOL%%EOL%    // look up biome:%EOL%    oe_GroundCover_Biome biome;%EOL%    oe_GroundCover_getBiome(biomeIndex, biome);%EOL%%EOL%    // discard instances based on noise value threshold (fill).%EOL%%EOL%    float fill = biome.fill;%EOL%%EOL%    float fillEdgeFactor = 1.0;%EOL%%EOL%#ifdef OE_GROUNDCOVER_COLOR_SAMPLER%EOL%    //fill = 1.0; // for color sampling%EOL%    vec4 c = texture(OE_GROUNDCOVER_COLOR_SAMPLER, (OE_GROUNDCOVER_COLOR_MATRIX*oe_layer_tilec).st);%EOL%    vec3 hsv = rgb2hsv(c.rgb);%EOL%    float hue_dot = -cos((oe_grass_hue/360.0)*6.2831853); // [-1..1]%EOL%    float hsv_dot = -cos(hsv[0]*6.2831853); // [-1..1]%EOL%    float hue_delta = 0.5*abs(hue_dot - hsv_dot); // [0..1]%EOL%    if (oe_grass_hueWidth < hue_delta) {%EOL%        float f = (oe_grass_hueWidth/hue_delta);%EOL%        fill *= f*f*f;%EOL%    }%EOL%    if (hsv[1] < oe_grass_saturation) {%EOL%        float f = (hsv[1]/oe_grass_saturation);%EOL%        fill *= f*f;%EOL%    }%EOL%#endif%EOL%%EOL%    if ( oe_noise[NOISE_SMOOTH] > fill )%EOL%    {%EOL%        return;%EOL%    }%EOL%    else%EOL%    {%EOL%        // scale the smooth-noise back up to [0..1] and compute an edge factor%EOL%        // that will shrink the foliage near the fill boundaries%EOL%        oe_noise[NOISE_SMOOTH] /= fill;%EOL%        const float xx = 0.5;%EOL%        if (oe_noise[NOISE_SMOOTH] > xx)%EOL%            fillEdgeFactor = 1.0-((oe_noise[NOISE_SMOOTH]-xx)/(1.0-xx));%EOL%    }%EOL%%EOL%    // select a billboard at %QUOTE%random%QUOTE% .. TODO: still order-dependent; needs work%EOL%    float pickNoise = (1.0-oe_noise[NOISE_SMOOTH]);%EOL%    int objectIndex = biome.firstObjectIndex + int(floor(pickNoise * float(biome.numObjects)));%EOL%    objectIndex = clamp(objectIndex, biome.firstObjectIndex, biome.firstObjectIndex + biome.numObjects - 1);%EOL%%EOL%    // Recover the object we randomly picked and its billboard%EOL%    oe_GroundCover_Object object;%EOL%    oe_GroundCover_getObject(objectIndex, object);%EOL%    oe_GroundCover_Billboard billboard;%EOL%    oe_GroundCover_getBillboard(object.objectArrayIndex, billboard);%EOL%%EOL%    oe_GroundCover_atlasIndex = float(billboard.atlasIndexSide);%EOL%%EOL%    // push the falloff closer to the max distance.%EOL%    float falloff = 1.0-(nRange*nRange*nRange);%EOL%%EOL%    // a pseudo-random scale factor to the width and height of a billboard%EOL%    //float sizeScale = billboard.sizeVariation * (oe_noise[NOISE_RANDOM_2]*2.0-1.0);%EOL%    float sizeScale = billboard.sizeVariation * (oe_noise[NOISE_CLUMPY]*2.0-1.0);%EOL%%EOL%    float width = (billboard.width + billboard.width*sizeScale) * clamp(fillEdgeFactor*2,0,1);%EOL%%EOL%    // need abs here but not sure why... todo%EOL%    float height = abs((billboard.height + billboard.height*sizeScale) * fillEdgeFactor);%EOL%%EOL%    // ratio of adjusted height to nonimal height%EOL%    float heightRatio = height/billboard.height;%EOL%%EOL%    int which = gl_VertexID & 15; // mod16 - there are 16 verts per instance%EOL%%EOL%    vp_Color = vec4(1,1,1,falloff);%EOL%%EOL%    // darken as the fill level decreases%EOL%    vp_Color.rgb *= 0.5+( decel(fillEdgeFactor)*(1.0-0.5) );%EOL%%EOL%    // texture coordinate:%EOL%    float row = float(which/4);%EOL%    oe_GroundCover_texCoord.t = (1.0/3.0)*row;%EOL%%EOL%    // random rotation; do this is model space and then transform%EOL%    // the vector to view space.%EOL%    float a = 6.283185 * fract(oe_noise[NOISE_RANDOM_2]*5.5);%EOL%    vec3 faceVec = gl_NormalMatrix * vec3(-sin(a), cos(a), 0);%EOL%%EOL%    // local frame side vector%EOL%    vec3 sideVec = cross(faceVec, oe_UpVectorView);%EOL%%EOL%    // make a curved billboard%EOL%    if ((which&3) == 0) { // col 0%EOL%        vertex.xyz += -sideVec*width*0.5 -faceVec*width*0.1;%EOL%        oe_GroundCover_texCoord.s = 0.0;%EOL%    }%EOL%    else if (((which-1)&3) == 0) { // col 1%EOL%        vertex.xyz += -sideVec*width*0.15 +faceVec*width*0.1;%EOL%        oe_GroundCover_texCoord.s = (1.0/3.0);%EOL%    }%EOL%    else if (((which-2)&3) == 0) { // col 2%EOL%        vertex.xyz += sideVec*width*0.15 +faceVec*width*0.1;%EOL%        oe_GroundCover_texCoord.s = (2.0/3.0);%EOL%    }%EOL%    else { // col 3%EOL%        vertex.xyz += sideVec*width*0.5 -faceVec*width*0.1;%EOL%        oe_GroundCover_texCoord.s = 1.0;%EOL%    }%EOL%%EOL%    // extrude to height:%EOL%    vertex.xyz += oe_UpVectorView * height * oe_GroundCover_texCoord.t;%EOL%%EOL%    // normal:%EOL%    vp_Normal = oe_UpVectorView;%EOL%%EOL%    // For bending, exaggerate effect as we climb the stalk%EOL%    vec3 bendVec = vec3(0.0);%EOL%    float bendPower = pow(3.0*oe_GroundCover_texCoord.t, 2.0);%EOL%%EOL%    // effect of gravity:%EOL%    const float gravity = 0.025; // 0=no bend, 1=insane megabend%EOL%    bendVec += faceVec * heightRatio * gravity * bendPower;%EOL%%EOL%    // wind:%EOL%    if (oe_GroundCover_wind > 0.0)%EOL%    {%EOL%        float windEffect = oe_GroundCover_wind * heightRatio * bendPower * 0.2 * falloff;%EOL%%EOL%#ifdef OE_GROUNDCOVER_USE_ACTOR%EOL%        vec3 windPos = (osg_ViewMatrix * vec4(actorPos, 1)).xyz;%EOL%        windPos += oe_UpVectorView * actorHeight;%EOL%%EOL%        // macro:%EOL%        vec3 windvec = vertex.xyz - windPos;%EOL%        float attenuation = clamp(actorRadius/length(windvec), 0, 1);%EOL%        attenuation *= attenuation;%EOL%        bendVec += normalize(windvec) * windEffect * attenuation;%EOL%%EOL%        // micro turbulence%EOL%        vec2 turbUV = oe_layer_tilec.xy + (1.0-oe_GroundCover_wind)*osg_FrameTime;%EOL%        vec2 turb = textureLod(oe_GroundCover_noiseTex, turbUV, 0).xw * 2 - 1;%EOL%        bendVec += gl_NormalMatrix * vec3(turb.xy, 0) * windEffect * attenuation;%EOL%#else%EOL%        const vec2 turbFreq = vec2(0.01);%EOL%        vec2 turbUV = oe_layer_tilec.xy + turbFreq*osg_FrameTime;%EOL%        vec2 turb = textureLod(oe_GroundCover_noiseTex, turbUV, 0).xw * 2 - 1;%EOL%        bendVec += gl_NormalMatrix * vec3(turb.xy, 0) * windEffect;%EOL%#endif%EOL%    }%EOL%%EOL%    vertex.xyz += bendVec;%EOL%%EOL%}%EOL%%EOL%%EOL%[break]%EOL%#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%#pragma vp_name GroundCover frag shader%EOL%#pragma vp_entryPoint oe_Grass_FS%EOL%#pragma vp_location fragment%EOL%%EOL%#pragma import_defines(OE_GROUNDCOVER_COLOR_SAMPLER)%EOL%#pragma import_defines(OE_GROUNDCOVER_COLOR_MATRIX)%EOL%%EOL%#ifdef OE_GROUNDCOVER_COLOR_SAMPLER%EOL%uniform sampler2D OE_GROUNDCOVER_COLOR_SAMPLER ;%EOL%uniform mat4 OE_GROUNDCOVER_COLOR_MATRIX ;%EOL%in vec4 oe_layer_tilec;%EOL%#endif%EOL%%EOL%uniform sampler2DArray oe_GroundCover_billboardTex;%EOL%in vec2 oe_GroundCover_texCoord;%EOL%flat in float oe_GroundCover_atlasIndex;%EOL%vec3 vp_Normal;%EOL%%EOL%uniform float oe_GroundCover_maxAlpha;%EOL%uniform int oe_GroundCover_A2C;%EOL%%EOL%void oe_Grass_FS(inout vec4 color)%EOL%{%EOL%    if (oe_GroundCover_atlasIndex < 0.0)%EOL%        discard;%EOL%%EOL%    // paint the texture%EOL%    color = texture(oe_GroundCover_billboardTex, vec3(oe_GroundCover_texCoord, oe_GroundCover_atlasIndex)) * color;%EOL%%EOL%    if (oe_GroundCover_A2C == 1)%EOL%    {%EOL%        // https://medium.com/@bgolus/anti-aliased-alpha-test-the-esoteric-alpha-to-coverage-8b177335ae4f%EOL%        color.a = (color.a - oe_GroundCover_maxAlpha) / max(fwidth(color.a), 0.0001) + 0.5;%EOL%    }%EOL%    else if (color.a < oe_GroundCover_maxAlpha)%EOL%    {%EOL%        discard;%EOL%    }%EOL%%EOL%%EOL%#ifdef OE_GROUNDCOVER_COLOR_SAMPLER%EOL%    const float modulation = 0.75;%EOL%    float mono = (color.r*0.2126 + color.g*0.7152 + color.b*0.0722);%EOL%    vec4 mod_color = texture(OE_GROUNDCOVER_COLOR_SAMPLER, (OE_GROUNDCOVER_COLOR_MATRIX*oe_layer_tilec).st);%EOL%    color.rgb = mix(color.rgb, mod_color.rgb*vec3(mono)*2.0, modulation);%EOL%#endif%EOL%}%EOL%%EOL%";

    GroundCover_VS = "GroundCover.VS.glsl";
    _sources[GroundCover_VS] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_name       GroundCover vertex shader%EOL%#pragma vp_entryPoint oe_GroundCover_VS%EOL%#pragma vp_location   vertex_view%EOL%%EOL%#pragma import_defines(OE_GROUNDCOVER_USE_INSTANCING)%EOL%#pragma import_defines(OE_LANDCOVER_TEX)%EOL%#pragma import_defines(OE_LANDCOVER_TEX_MATRIX)%EOL%#pragma import_defines(OE_GROUNDCOVER_MASK_SAMPLER)%EOL%#pragma import_defines(OE_GROUNDCOVER_MASK_MATRIX)%EOL%#pragma import_defines(OE_IS_SHADOW_CAMERA)%EOL%%EOL%// Noise texture:%EOL%uniform sampler2D oe_GroundCover_noiseTex;%EOL%%EOL%// noise texture channels:%EOL%#define NOISE_SMOOTH   0%EOL%#define NOISE_RANDOM   1%EOL%#define NOISE_RANDOM_2 2%EOL%#define NOISE_CLUMPY   3%EOL%%EOL%// LandCover texture%EOL%uniform sampler2D OE_LANDCOVER_TEX;%EOL%uniform mat4 OE_LANDCOVER_TEX_MATRIX;%EOL%out float oe_LandCover_coverage;%EOL%%EOL%#ifdef OE_GROUNDCOVER_MASK_SAMPLER%EOL%uniform sampler2D OE_GROUNDCOVER_MASK_SAMPLER;%EOL%uniform mat4 OE_GROUNDCOVER_MASK_MATRIX;%EOL%#endif%EOL%%EOL%uniform vec2 oe_GroundCover_numInstances;%EOL%uniform vec3 oe_GroundCover_LL, oe_GroundCover_UR;%EOL%%EOL%// 0=draw a textured billboard; 1=draw an instanced model%EOL%uniform int oe_GroundCover_instancedModel;%EOL%%EOL%uniform float oe_GroundCover_wind; // wind blowing the foliage%EOL%uniform float oe_GroundCover_maxDistance;     // distance at which flora disappears%EOL%%EOL%uniform vec3 oe_Camera;  // (vp width, vp height, lodscale)%EOL%%EOL%uniform float osg_FrameTime; // Frame time (seconds) used for wind animation%EOL%uniform mat4 osg_ViewMatrix;%EOL%%EOL%// Stage globals%EOL%vec3 oe_UpVectorView;%EOL%vec4 vp_Color;%EOL%vec3 vp_Normal;%EOL%vec4 oe_layer_tilec;%EOL%// Output grass texture coordinates to the fragment shader%EOL%out vec2 oe_GroundCover_texCoord;%EOL%%EOL%// Output that selects the land cover texture from the texture array (non interpolated)%EOL%flat out float oe_GroundCover_atlasIndex;%EOL%%EOL%out vec2 modelCoords;%EOL%%EOL%struct oe_GroundCover_Biome {%EOL%    int firstObjectIndex;%EOL%    int numObjects;%EOL%    float density;%EOL%    float fill;%EOL%    vec2 maxWidthHeight;%EOL%};%EOL%void oe_GroundCover_getBiome(in int index, out oe_GroundCover_Biome biome);%EOL%%EOL%struct oe_GroundCover_Object {%EOL%    int type;             // 0=billboard %EOL%    int objectArrayIndex; // index into the typed object array %EOL%};%EOL%void oe_GroundCover_getObject(in int index, out oe_GroundCover_Object object);%EOL%%EOL%struct oe_GroundCover_Billboard {%EOL%    int atlasIndexSide;%EOL%    int atlasIndexTop;%EOL%    float width;%EOL%    float height;%EOL%    float sizeVariation;%EOL%};%EOL%void oe_GroundCover_getBillboard(in int index, out oe_GroundCover_Billboard bb);%EOL%%EOL%// SDK import%EOL%float oe_terrain_getElevation(in vec2);%EOL%%EOL%// Generated in GroundCover.cpp%EOL%int oe_GroundCover_getBiomeIndex(in vec4);%EOL%%EOL%// Sample the elevation texture and move the vertex accordingly.%EOL%void oe_GroundCover_clamp(inout vec4 vert_view, in vec3 up, in vec2 UV)%EOL%{%EOL%    float elev = oe_terrain_getElevation( UV );%EOL%    vert_view.xyz += up*elev;%EOL%}%EOL%%EOL%// Generate a wind-perturbation value%EOL%float oe_GroundCover_applyWind(float time, float factor, float randOffset)%EOL%{%EOL%    return sin(time + randOffset) * factor;%EOL%}%EOL%%EOL%float rescale(float d, float v0, float v1)%EOL%{%EOL%    return clamp((d-v0)/(v1-v0), 0, 1);%EOL%}%EOL%%EOL%vec2 quantize(vec2 x, vec2 y)%EOL%{%EOL%    return (floor(x / y) * y);%EOL%}%EOL%%EOL%vec4 texture2D_bilinear_mesa(in sampler2D sampler, in vec2 tex_coord)%EOL%{%EOL%    const vec2 tex_size = vec2(256.0);%EOL%    vec2 unit_texel = 1.0 / tex_size;%EOL%    vec2 unnorm_tex_coord = (tex_coord * tex_size) - vec2(0.5);%EOL%    vec2 f = fract(unnorm_tex_coord);%EOL%    vec2 snap_tex_coord = (floor(unnorm_tex_coord) + vec2(0.5)) / tex_size;%EOL%    vec4 s1 = texture2D(sampler, snap_tex_coord);%EOL%    vec4 s2 = texture2D(sampler, snap_tex_coord + vec2(unit_texel.x, 0.));%EOL%    vec4 s3 = texture2D(sampler, snap_tex_coord + vec2(0., unit_texel.y));%EOL%    vec4 s4 = texture2D(sampler, snap_tex_coord + unit_texel);%EOL%    return mix(mix(s1, s2, f.x), mix(s3, s4, f.x), f.y);%EOL%}%EOL%%EOL%// MAIN ENTRY POINT  %EOL%void oe_GroundCover_VS(inout vec4 vertex_view)%EOL%{%EOL%    // intialize with a %QUOTE%no draw%QUOTE% value (consider using a compute/gs cull instead)%EOL%    oe_GroundCover_atlasIndex = -1.0;%EOL%%EOL%    int instanceID;%EOL%    if (oe_GroundCover_instancedModel == 1)%EOL%    {%EOL%        instanceID = gl_InstanceID;%EOL%        modelCoords = gl_MultiTexCoord3.st;%EOL%    }%EOL%    else%EOL%    {%EOL%#ifdef OE_GROUNDCOVER_USE_INSTANCING%EOL%        instanceID = gl_InstanceID;%EOL%#else%EOL%        instanceID = gl_VertexID / 8;%EOL%#endif%EOL%    }%EOL%%EOL%    // Generate the UV tile coordinates (tilec) based on the instance number%EOL%    vec2 offset = vec2(%EOL%        float(instanceID % int(oe_GroundCover_numInstances.x)),%EOL%        float(instanceID / int(oe_GroundCover_numInstances.y)));%EOL%%EOL%    // half the distance between cell centers%EOL%    vec2 halfSpacing = 0.5 / oe_GroundCover_numInstances;%EOL%%EOL%    // tile coords [0..1]%EOL%    oe_layer_tilec = vec4(halfSpacing + offset / oe_GroundCover_numInstances, 0, 1);%EOL%%EOL%    vec4 noise = textureLod(oe_GroundCover_noiseTex, oe_layer_tilec.st, 0);%EOL%%EOL%    // randomly shift each point off center%EOL%    vec2 shift = vec2(fract(noise[NOISE_RANDOM]*1.5), fract(noise[NOISE_RANDOM_2]*1.5))*2.0-1.0;%EOL%%EOL%    oe_layer_tilec.xy += shift * halfSpacing;%EOL%%EOL%    // and place it correctly within the tile%EOL%    vec3 pos = gl_NormalMatrix * vec3(mix(oe_GroundCover_LL.xy, oe_GroundCover_UR.xy, oe_layer_tilec.xy), 0);%EOL%%EOL%    vertex_view.xyz += pos;%EOL%%EOL%    if (oe_GroundCover_instancedModel == 0)%EOL%    {%EOL%        vp_Normal = vec3(0, 0, 1);%EOL%        vp_Color = vec4(1, 1, 1, 0);%EOL%    }%EOL%%EOL%    // sample the landcover data%EOL%    oe_LandCover_coverage = textureLod(OE_LANDCOVER_TEX, (OE_LANDCOVER_TEX_MATRIX*oe_layer_tilec).st, 0).r;%EOL%%EOL%    // Look up the biome at this point:%EOL%    int biomeIndex = oe_GroundCover_getBiomeIndex(oe_layer_tilec);%EOL%    if ( biomeIndex < 0 )%EOL%    {%EOL%        // No biome defined; bail out without emitting any geometry.%EOL%        return;%EOL%    }%EOL%%EOL%    // If we're using a mask texture, sample it now:%EOL%#ifdef OE_GROUNDCOVER_MASK_SAMPLER%EOL%    float mask = texture(OE_GROUNDCOVER_MASK_SAMPLER, (OE_GROUNDCOVER_MASK_MATRIX*oe_layer_tilec).st).a;%EOL%    if ( mask > 0.0 )%EOL%    {%EOL%        // Failed to pass the mask; no geometry emitted.%EOL%        return;%EOL%    }%EOL%#endif%EOL%%EOL%    // look up biome:%EOL%    oe_GroundCover_Biome biome;%EOL%    oe_GroundCover_getBiome(biomeIndex, biome);%EOL%%EOL%    // discard instances based on noise value threshold (coverage). If it passes,%EOL%    // scale the noise value back up to [0..1]%EOL%    if (noise[NOISE_SMOOTH] > biome.fill)%EOL%        return;%EOL%    else%EOL%        noise[NOISE_SMOOTH] /= biome.fill;%EOL%%EOL%    // Clamp the center point to the elevation.%EOL%    oe_GroundCover_clamp(vertex_view, oe_UpVectorView, oe_layer_tilec.st);%EOL%%EOL%    // Calculate the normalized camera range (oe_Camera.z = LOD Scale)%EOL%    float maxRange = oe_GroundCover_maxDistance / oe_Camera.z;%EOL%    float nRange = clamp(-vertex_view.z/maxRange, 0.0, 1.0);%EOL%%EOL%    // Distance culling:%EOL%    if ( nRange == 1.0 )%EOL%        return;%EOL%%EOL%    // Instancing? We are finished%EOL%    if (oe_GroundCover_instancedModel == 1)%EOL%    {%EOL%        oe_GroundCover_atlasIndex = 1.0;%EOL%        return;%EOL%    }%EOL%%EOL%    // select a billboard at random%EOL%    int objectIndex = biome.firstObjectIndex + int(floor(noise[NOISE_RANDOM] * float(biome.numObjects)));%EOL%    objectIndex = min(objectIndex, biome.firstObjectIndex + biome.numObjects - 1);%EOL%%EOL%    // Recover the object we randomly picked:%EOL%    oe_GroundCover_Object object;%EOL%    oe_GroundCover_getObject(objectIndex, object);%EOL%%EOL%    // for now, assume type == BILLBOARD.%EOL%    // Find the billboard associated with the object:%EOL%    oe_GroundCover_Billboard billboard;%EOL%    oe_GroundCover_getBillboard(object.objectArrayIndex, billboard);%EOL%%EOL%    oe_GroundCover_atlasIndex = float(billboard.atlasIndexSide);%EOL%%EOL%    // push the falloff closer to the max distance.%EOL%    float falloff = 1.0-(nRange*nRange*nRange);%EOL%%EOL%    // a pseudo-random scale factor to the width and height of a billboard%EOL%    float sizeScale = billboard.sizeVariation * (noise[NOISE_RANDOM_2]*2.0-1.0);%EOL%%EOL%    float width = (billboard.width + billboard.width*sizeScale) * falloff;%EOL%%EOL%    float height = (billboard.height + billboard.height*sizeScale) * falloff;%EOL%%EOL%    int which = gl_VertexID & 7; // mod8 - there are 8 verts per instance%EOL%%EOL%#ifdef OE_IS_SHADOW_CAMERA%EOL%%EOL%    // For a shadow camera, draw the tree as a cross hatch model instead of a billboard.%EOL%    vp_Color = vec4(1,1,1,falloff);%EOL%    vec3 heightVector = oe_UpVectorView*height;%EOL%    vec3 tangentVector;%EOL%%EOL%    if (which < 4)%EOL%    {%EOL%        // first quad%EOL%        tangentVector = gl_NormalMatrix * vec3(1,0,0); // vector pointing east-ish.%EOL%    }%EOL%    else%EOL%    {%EOL%        // second quad%EOL%        tangentVector = gl_NormalMatrix * vec3(0,1,0);%EOL%    }%EOL%%EOL%    vec3 halfWidthTangentVector = cross(tangentVector, oe_UpVectorView) * 0.5 * width;%EOL%%EOL%    vertex_view.xyz =%EOL%        which==0? vertex_view.xyz - halfWidthTangentVector :%EOL%        which==1? vertex_view.xyz + halfWidthTangentVector :%EOL%        which==2? vertex_view.xyz - halfWidthTangentVector + heightVector :%EOL%        vertex_view.xyz + halfWidthTangentVector + heightVector;%EOL%%EOL%    vp_Normal = normalize(cross(tangentVector, heightVector));%EOL%%EOL%#else // normal render camera - draw as a billboard:%EOL%%EOL%    vec3 tangentVector = normalize(cross(vertex_view.xyz, oe_UpVectorView));%EOL%    vec3 halfWidthTangentVector = tangentVector * 0.5 * width;%EOL%    vec3 heightVector = oe_UpVectorView*height;%EOL%%EOL%    // Color variation, brightness, and contrast:%EOL%    //vec3 color = vec3(0.75+0.25*noise[NOISE_RANDOM_2]);%EOL%    //color = ( ((color - 0.5) * oe_GroundCover_contrast + 0.5) * oe_GroundCover_brightness);%EOL%%EOL%    float d = clamp(dot(vec3(0,0,1), oe_UpVectorView), 0, 1);%EOL%    float topDownAmount = rescale(d, 0.4, 0.6);%EOL%    float billboardAmount = rescale(1.0-d, 0.0, 0.25);%EOL%%EOL%    if (which < 4 && billboard.atlasIndexSide >= 0 && billboardAmount > 0.0) // Front-facing billboard%EOL%    {%EOL%        vertex_view = %EOL%            which == 0? vec4(vertex_view.xyz - halfWidthTangentVector, 1.0) :%EOL%            which == 1? vec4(vertex_view.xyz + halfWidthTangentVector, 1.0) :%EOL%            which == 2? vec4(vertex_view.xyz - halfWidthTangentVector + heightVector, 1.0) :%EOL%            vec4(vertex_view.xyz + halfWidthTangentVector + heightVector, 1.0);%EOL%#%EOL%        // animate based on wind parameters.%EOL%        if (which >= 2 && oe_GroundCover_wind > 0)%EOL%        {%EOL%            float nw = noise[NOISE_SMOOTH];%EOL%            float wind = width*oe_GroundCover_wind*nw;%EOL%            vertex_view.x += oe_GroundCover_applyWind(osg_FrameTime*(1+nw), wind, oe_layer_tilec.s);%EOL%            vertex_view.x += oe_GroundCover_applyWind(osg_FrameTime*(1-nw), wind, oe_layer_tilec.t);%EOL%        }%EOL%%EOL%        // calculates normals:%EOL%        vec3 faceNormalVector = normalize(cross(tangentVector, heightVector));%EOL%%EOL%        if (billboardAmount > 0.1)%EOL%        {%EOL%            vp_Color.a = falloff * billboardAmount;%EOL%%EOL%            float blend = 0.25 + (noise[NOISE_RANDOM_2]*0.25);%EOL%%EOL%            vp_Normal =%EOL%                which == 0 || which == 2? mix(-tangentVector, faceNormalVector, blend) :%EOL%                mix( tangentVector, faceNormalVector, blend);%EOL%%EOL%            oe_GroundCover_atlasIndex = float(billboard.atlasIndexSide);%EOL%        }%EOL%    }%EOL%%EOL%    else if (which >= 4 && billboard.atlasIndexTop >= 0 && topDownAmount > 0.0) // top-down billboard%EOL%    {%EOL%        oe_GroundCover_atlasIndex = float(billboard.atlasIndexTop);%EOL%%EOL%        // estiblish the local tangent plane:%EOL%        vec3 Z = mat3(osg_ViewMatrix) * vec3(0,0,1); //north pole%EOL%        vec3 E = cross(Z, oe_UpVectorView);%EOL%        vec3 N = cross(oe_UpVectorView, E);%EOL%%EOL%        // now introduce a %QUOTE%random%QUOTE% rotation%EOL%        vec2 b = normalize(clamp(vec2(noise[NOISE_RANDOM], noise[NOISE_RANDOM_2]), 0.01, 1.0)*2.0-1.0);%EOL%        N = normalize(E*b.x + N*b.y);%EOL%        E = normalize(cross(N, oe_UpVectorView));%EOL%%EOL%        // a little trick to mitigate z-fighting amongst the topdowns.%EOL%        float yclip = noise[NOISE_RANDOM] * 0.1;%EOL%%EOL%        float k = width * 0.5;%EOL%        vec3 C = vertex_view.xyz + (heightVector*(0.4+yclip));%EOL%        vertex_view =%EOL%            which == 4? vec4(C - E*k - N*k, 1.0) :%EOL%            which == 5? vec4(C + E*k - N*k, 1.0) :%EOL%            which == 6? vec4(C - E*k + N*k, 1.0) :%EOL%                        vec4(C + E*k + N*k, 1.0);%EOL%%EOL%        vp_Normal = vertex_view.xyz - C;%EOL%%EOL%        vp_Color.a = topDownAmount;%EOL%    }%EOL%%EOL%#endif // !OE_IS_SHADOW_CAMERA%EOL%%EOL%    oe_GroundCover_texCoord =%EOL%        which == 0 || which == 4? vec2(0, 0) :%EOL%        which == 1 || which == 5? vec2(1, 0) :%EOL%        which == 2 || which == 6? vec2(0, 1) :%EOL%        vec2(1, 1);%EOL%}%EOL%%EOL%";
    
    GroundCover_TCS = "GroundCover.TCS.glsl";
    _sources[GroundCover_TCS] = "#version 400%EOL%%EOL%/**%EOL% * TCS that assigns a patch grid density.%EOL% */%EOL% %EOL%#pragma vp_name       GroundCover tessellation control shader%EOL%#pragma vp_entryPoint oe_GroundCover_configureTess%EOL%#pragma vp_location   tess_control%EOL%%EOL%layout(vertices=3) out;%EOL%%EOL%uniform float oe_GroundCover_density;%EOL%%EOL%// per-vertex tile coordinates%EOL%vec4 oe_layer_tilec;%EOL%%EOL%#ifdef OE_GROUNDCOVER_COVERAGE_PRECHECK%EOL%// SDK function to sample the coverage data%EOL%int oe_GroundCover_getBiomeIndex(in vec4);%EOL%%EOL%// SDK function to load per-vertex data%EOL%void VP_LoadVertex(in int);%EOL%#endif%EOL%%EOL%// MAIN ENTRY POINT                %EOL%void oe_GroundCover_configureTess()%EOL%{%EOL%	if (gl_InvocationID == 0)%EOL%	{%EOL%        float d = oe_GroundCover_density;%EOL%%EOL%#ifdef OE_GROUNDCOVER_COVERAGE_PRECHECK%EOL%        // Samples the three corner points to see whether the triangle%EOL%        // is likely to contain a groundcover biome. This is not perfect%EOL%        // since it only samples the corner points, and the performance%EOL%        // benefits are questionable. -gw%EOL%        VP_LoadVertex(0);%EOL%        if ( oe_GroundCover_getBiomeIndex(oe_layer_tilec) >= 0 ) {%EOL%            d = oe_GroundCover_density;%EOL%        }%EOL%        else {%EOL%            VP_LoadVertex(1);%EOL%            if ( oe_GroundCover_getBiomeIndex(oe_layer_tilec) >= 0 ) {%EOL%                d = oe_GroundCover_density;%EOL%                VP_LoadVertex(0);%EOL%            }%EOL%            else {%EOL%                VP_LoadVertex(2);%EOL%                if ( oe_GroundCover_getBiomeIndex(oe_layer_tilec) >= 0 ) {%EOL%                    d = oe_GroundCover_density;%EOL%                    VP_LoadVertex(0);%EOL%                }%EOL%            }%EOL%        }%EOL%#endif%EOL%%EOL%        gl_TessLevelOuter[0] = d;%EOL%        gl_TessLevelOuter[1] = d;%EOL%        gl_TessLevelOuter[2] = d;%EOL%        gl_TessLevelInner[0] = d+1;%EOL%	}%EOL%}%EOL%%EOL%";

    GroundCover_TES = "GroundCover.TES.glsl";
    _sources[GroundCover_TES] = "#version 410%EOL%%EOL%#pragma vp_name       GroundCover TES Shader%EOL%#pragma vp_entryPoint oe_GroundCover_tessellate%EOL%#pragma vp_location   tess_eval%EOL%%EOL%// osgEarth terrain is always CCW winding%EOL%layout(triangles, equal_spacing, ccw) in;%EOL%%EOL%// Internal helpers:%EOL%void VP_Interpolate3();%EOL%void VP_EmitVertex();%EOL%%EOL%float VP_Interpolate3(float a, float b, float c) %EOL%{%EOL%    return dot(gl_TessCoord.xyz, vec3(a,b,c));%EOL%}%EOL%%EOL%vec2 VP_Interpolate3(vec2 a, vec2 b, vec2 c) %EOL%{%EOL%    return vec2(dot(gl_TessCoord.xyz, vec3(a.x,b.x,c.x)),%EOL%	dot(gl_TessCoord.xyz, vec3(a.y,b.y,c.y)));%EOL%}%EOL%%EOL%vec3 VP_Interpolate3(vec3 a, vec3 b, vec3 c) %EOL%{%EOL%    return vec3(dot(gl_TessCoord.xyz, vec3(a.x,b.x,c.x)),%EOL%	dot(gl_TessCoord.xyz, vec3(a.y,b.y,c.y)),%EOL%	dot(gl_TessCoord.xyz, vec3(a.z,b.z,c.z)));%EOL%}%EOL%%EOL%vec4 VP_Interpolate3(vec4 a, vec4 b, vec4 c) %EOL%{%EOL%    return vec4(dot(gl_TessCoord.xyz, vec3(a.x,b.x,c.x)),%EOL%				dot(gl_TessCoord.xyz, vec3(a.y,b.y,c.y)),%EOL%				dot(gl_TessCoord.xyz, vec3(a.z,b.z,c.z)),%EOL%				dot(gl_TessCoord.xyz, vec3(a.w,b.w,c.w)));%EOL%}%EOL%%EOL%                %EOL%vec3 vp_Normal;%EOL%%EOL%// simplest possible pass-though:%EOL%void oe_GroundCover_tessellate()%EOL%{%EOL%    VP_Interpolate3();%EOL%    // Must re-normalize the normal vector since interpolation was linear?%EOL%	//vp_Normal = normalize(vp_Normal);%EOL%    VP_EmitVertex();%EOL%}%EOL%%EOL%";

    GroundCover_GS = "GroundCover.GS.glsl";
    _sources[GroundCover_GS] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%#pragma vp_name       GroundCover geometry shader%EOL%#pragma vp_entryPoint oe_GroundCover_geom%EOL%#pragma vp_location   geometry%EOL%%EOL%#pragma import_defines(OE_IS_SHADOW_CAMERA)%EOL%#pragma import_defines(OE_GROUNDCOVER_MASK_SAMPLER)%EOL%#pragma import_defines(OE_GROUNDCOVER_MASK_MATRIX)%EOL%#pragma import_defines(OE_GROUNDCOVER_USE_TOP_BILLBOARDS)%EOL%#pragma import_defines(OE_GROUNDCOVER_SHOW_TESSELLATION)%EOL%                %EOL%layout(triangles) in;        // triangles from the TileDrawable%EOL%%EOL%#ifdef OE_GROUNDCOVER_SHOW_TESSELLATION%EOL%    layout(line_strip, max_vertices=4) out;%EOL%#else%EOL%    #ifdef OE_GROUNDCOVER_USE_TOP_BILLBOARDS%EOL%        layout(triangle_strip, max_vertices=8) out;%EOL%    #else%EOL%        layout(triangle_strip, max_vertices=4) out;%EOL%    #endif%EOL%#endif%EOL%%EOL%// VP helper functions:%EOL%void VP_LoadVertex(in int);%EOL%void VP_EmitViewVertex();%EOL%%EOL%uniform float osg_FrameTime;            // Frame time (seconds) used for wind animation%EOL%                %EOL%uniform float oe_GroundCover_ao;              // fake ambient occlusion of ground verts (0=full)%EOL%uniform float oe_GroundCover_fill;            // percentage of points that make it through, based on noise function%EOL%uniform float oe_GroundCover_windFactor;      // wind blowing the foliage%EOL%uniform float oe_GroundCover_maxDistance;     // distance at which flora disappears%EOL%uniform float oe_GroundCover_contrast;%EOL%uniform float oe_GroundCover_brightness;%EOL%%EOL%uniform vec3 oe_Camera; // (vp width, vp height, lodscale)%EOL%%EOL%// Noise texture:%EOL%uniform sampler2D oe_GroundCover_noiseTex;%EOL%%EOL%// noise texture channels:%EOL%#define NOISE_SMOOTH   0%EOL%#define NOISE_RANDOM   1%EOL%#define NOISE_RANDOM_2 2%EOL%#define NOISE_CLUMPY   3%EOL%%EOL%// Tile coordinates [0..1]%EOL%in vec4 oe_layer_tilec;%EOL%%EOL%// Output tex coords%EOL%out vec2 oe_GroundCover_texCoord;%EOL%%EOL%// Output that selects the land cover texture from the texture array%EOL%flat out float oe_GroundCover_atlasIndex;%EOL%%EOL%struct oe_GroundCover_Biome {%EOL%    int firstObjectIndex;%EOL%    int numObjects;%EOL%    float density;%EOL%    float fill;%EOL%    vec2 maxWidthHeight;%EOL%};%EOL%void oe_GroundCover_getBiome(in int index, out oe_GroundCover_Biome biome);%EOL%%EOL%struct oe_GroundCover_Object {%EOL%    int type;             // 0=billboard %EOL%    int objectArrayIndex; // index into the typed object array %EOL%};%EOL%void oe_GroundCover_getObject(in int index, out oe_GroundCover_Object object);%EOL%%EOL%struct oe_GroundCover_Billboard {%EOL%    int atlasIndexSide;%EOL%    int atlasIndexTop;%EOL%    float width;%EOL%    float height;%EOL%    float sizeVariation;%EOL%};%EOL%void oe_GroundCover_getBillboard(in int index, out oe_GroundCover_Billboard bb);%EOL%%EOL%%EOL%// Output colors/normals:%EOL%out vec4 vp_Color;%EOL%out vec3 vp_Normal;%EOL%%EOL%float oe_terrain_getElevation(in vec2); // SDK import%EOL%int oe_GroundCover_getBiomeIndex(in vec4 coords); // Generated in code%EOL%%EOL%#ifdef OE_GROUNDCOVER_MASK_SAMPLER%EOL%uniform sampler2D OE_GROUNDCOVER_MASK_SAMPLER;%EOL%uniform mat4 OE_GROUNDCOVER_MASK_MATRIX;%EOL%#endif%EOL%%EOL%// Sample the elevation texture and move the vertex accordingly.%EOL%void%EOL%oe_GroundCover_clamp(inout vec4 vert_view, in vec3 up, vec2 UV)%EOL%{%EOL%    float elev = oe_terrain_getElevation( UV );%EOL%    vert_view.xyz += up*elev;%EOL%}%EOL%%EOL%// Generate a pseudo-random value%EOL%float oe_GroundCover_rangeRand(float minValue, float maxValue, vec2 co)%EOL%{%EOL%    float t = fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);%EOL%    return minValue + t*(maxValue-minValue);%EOL%}%EOL%%EOL%// Generate a wind-perturbation value%EOL%float oe_GroundCover_applyWind(float time, float factor, float randOffset)%EOL%{%EOL%   return sin(time + randOffset) * factor;%EOL%}%EOL%%EOL%// Generate a random barycentric point inside a triangle.%EOL%vec3 oe_GroundCover_getRandomBarycentricPoint(vec2 seed)%EOL%{%EOL%    vec3 b;%EOL%    b[0] = oe_GroundCover_rangeRand(0.0, 1.0, seed.xy);%EOL%    b[1] = oe_GroundCover_rangeRand(0.0, 1.0, seed.yx);%EOL%    if (b[0]+b[1] >= 1.0)%EOL%    {%EOL%        b[0] = 1.0 - b[0];%EOL%        b[1] = 1.0 - b[1];%EOL%    }%EOL%    b[2] = 1.0 - b[0] - b[1];%EOL%    return b;%EOL%}%EOL%%EOL%uniform float shmoo;%EOL%%EOL%float oe_GroundCover_fastpow(in float x, in float y)%EOL%{%EOL%    return x / (x + y - y * x);%EOL%}%EOL%%EOL%void oe_GroundCover_geom()%EOL%{    %EOL%    vec4 center = vec4(0,0,0,1);%EOL%    vec2 tileUV = vec2(0,0);%EOL%%EOL%#ifdef OE_GROUNDCOVER_SHOW_TESSELLATION%EOL%    for(int i=0; i < 3; ++i)%EOL%    {%EOL%        VP_LoadVertex(i);      %EOL%        gl_Position = gl_in[i].gl_Position;%EOL%        gl_Position.z += 10.0;%EOL%        gl_Position = gl_ModelViewMatrix * gl_Position;%EOL%        VP_EmitViewVertex();%EOL%    }%EOL%    VP_LoadVertex(0);    %EOL%    gl_Position = gl_in[0].gl_Position;%EOL%    gl_Position.z += 10.0;%EOL%    gl_Position = gl_ModelViewMatrix * gl_Position;%EOL%    VP_EmitViewVertex();%EOL%%EOL%    EndPrimitive();%EOL%    return;%EOL%#endif%EOL%        %EOL%    // gen a random point within the input triangle%EOL%    vec3 b = oe_GroundCover_getRandomBarycentricPoint(gl_in[0].gl_Position.xy);%EOL%    %EOL%    // Load tri data and compute new position and tile coords using the barycentric coords%EOL%    for(int i=0; i < 3; ++i)%EOL%    {%EOL%        VP_LoadVertex(i);      %EOL%        %EOL%        center.x += b[i] * gl_in[i].gl_Position.x;%EOL%        center.y += b[i] * gl_in[i].gl_Position.y;%EOL%        center.z += b[i] * gl_in[i].gl_Position.z;%EOL%        %EOL%        tileUV.x += b[i] * oe_layer_tilec.x;%EOL%        tileUV.y += b[i] * oe_layer_tilec.y;%EOL%    }%EOL%   %EOL%    // Look up the biome at this point:%EOL%    int biomeIndex = oe_GroundCover_getBiomeIndex(vec4(tileUV,0,1));%EOL%    if ( biomeIndex < 0 )%EOL%    {%EOL%        // No biome defined; bail out without emitting any geometry.%EOL%        return;%EOL%    }%EOL%    %EOL%    // If we're using a mask texture, sample it now:%EOL%#ifdef OE_GROUNDCOVER_MASK_SAMPLER%EOL%    float mask = texture(OE_GROUNDCOVER_MASK_SAMPLER, (OE_GROUNDCOVER_MASK_MATRIX*vec4(tileUV,0,1)).st).a;%EOL%    if ( mask > 0.0 )%EOL%        return;%EOL%#endif%EOL%    %EOL%    // Transform to view space.%EOL%    vec4 center_view = gl_ModelViewMatrix * center;%EOL%    vec3 up_view     = gl_NormalMatrix * vp_Normal;%EOL%    %EOL%    // Clamp the center point to the elevation.%EOL%    oe_GroundCover_clamp(center_view, up_view, tileUV);%EOL%%EOL%    // Calculate the normalized camera range (oe_Camera.z = LOD Scale)%EOL%    float maxRange = oe_GroundCover_maxDistance / oe_Camera.z;%EOL%    float nRange = clamp(-center_view.z/maxRange, 0.0, 1.0);%EOL%%EOL%    // Distance culling:%EOL%    if ( nRange == 1.0 )%EOL%        return;%EOL%%EOL%    // look up biome:%EOL%    oe_GroundCover_Biome biome;%EOL%    oe_GroundCover_getBiome(biomeIndex, biome);%EOL%%EOL%    // sample the noise texture.%EOL%    vec4 noise = texture(oe_GroundCover_noiseTex, tileUV);%EOL%    %EOL%    // Viewpoint culling (needs work)%EOL%    vec4 cullPoint = center_view;%EOL%    cullPoint.xy -= sign(cullPoint.xy) * min(biome.maxWidthHeight, abs(cullPoint.xy));%EOL%    cullPoint = gl_ProjectionMatrix * cullPoint;%EOL%    float absw = abs(cullPoint.w);%EOL%    if ( abs(cullPoint.x) > absw || abs(cullPoint.y) > absw )%EOL%        return;%EOL%%EOL%    // discard instances based on noise value threshold (coverage). If it passes,%EOL%    // scale the noise value back up to [0..1]%EOL%    if ( noise[NOISE_SMOOTH] > oe_GroundCover_fill )%EOL%        return;%EOL%    else%EOL%        noise[NOISE_SMOOTH] /= oe_GroundCover_fill;%EOL%%EOL%    // select a billboard seemingly at random. Need to scale n to account for the fill limit first though.%EOL%    int objectIndex = biome.firstObjectIndex + int(floor(noise[NOISE_RANDOM] * float(biome.numObjects)));%EOL%    objectIndex = min(objectIndex, biome.firstObjectIndex + biome.numObjects - 1);%EOL%%EOL%    // Recover the object we randomly picked:%EOL%    oe_GroundCover_Object object;%EOL%    oe_GroundCover_getObject(objectIndex, object);%EOL%%EOL%    // for now, assume type == BILLBOARD.%EOL%    // Find the billboard associated with the object:%EOL%    oe_GroundCover_Billboard billboard;%EOL%    oe_GroundCover_getBillboard(object.objectArrayIndex, billboard);%EOL%%EOL%    oe_GroundCover_atlasIndex = float(billboard.atlasIndexSide);%EOL%%EOL%    // push the falloff closer to the max distance%EOL%    // billboard size shrinks in the distance%EOL%    float falloff = 1.0-(nRange*nRange*nRange);%EOL%%EOL%    // a pseudo-random scale factor to the width and height of a billboard%EOL%    float sizeScale = billboard.sizeVariation * (noise[NOISE_RANDOM_2]*2.0-1.0);%EOL%%EOL%    float width = (billboard.width + billboard.width*sizeScale) * falloff;%EOL%    %EOL%    float height = (billboard.height + billboard.height*sizeScale) * falloff;%EOL%%EOL%	// compute the billboard corners in view space%EOL%    vec4 LL, LR, UL, UR;    %EOL%%EOL%#ifdef OE_IS_SHADOW_CAMERA%EOL%    %EOL%    vec3 tangentVector = gl_NormalMatrix * vec3(1,0,0);%EOL%    vec3 halfWidthTangentVector = cross(tangentVector, up_view) * 0.5 * width;%EOL%    vec3 heightVector = up_view*height;%EOL%    vp_Color = vec4(1,1,1,falloff);%EOL%%EOL%    for(int i=0; i<2; ++i)%EOL%    {%EOL%        LL = vec4(center_view.xyz - halfWidthTangentVector, 1.0);%EOL%        LR = vec4(center_view.xyz + halfWidthTangentVector, 1.0);%EOL%        UL = vec4(LL.xyz + heightVector, 1.0);%EOL%        UR = vec4(LR.xyz + heightVector, 1.0);%EOL%    %EOL%        vp_Normal = normalize(cross(tangentVector, heightVector));%EOL%        %EOL%        gl_Position = LL;%EOL%        oe_GroundCover_texCoord = vec2(0,0);%EOL%        VP_EmitViewVertex();%EOL%    %EOL%        gl_Position = LR;%EOL%        oe_GroundCover_texCoord = vec2(1,0);%EOL%        VP_EmitViewVertex();    %EOL%%EOL%        gl_Position = UL;%EOL%        oe_GroundCover_texCoord = vec2(0,1);%EOL%        VP_EmitViewVertex();%EOL%%EOL%        oe_GroundCover_texCoord = vec2(1,1);%EOL%        gl_Position = UR;%EOL%        VP_EmitViewVertex();%EOL%                    %EOL%        EndPrimitive();%EOL%%EOL%        tangentVector = gl_NormalMatrix * vec3(0,1,0);%EOL%        halfWidthTangentVector = cross(tangentVector, up_view) * 0.5 * width;%EOL%    }%EOL%%EOL%#else // normal render camera - draw as a billboard:%EOL%%EOL%    vec3 tangentVector = normalize(cross(center_view.xyz, up_view));%EOL%    vec3 halfWidthTangentVector = tangentVector * 0.5 * width;%EOL%    vec3 heightVector = up_view*height;%EOL%        %EOL%    LL = vec4(center_view.xyz - halfWidthTangentVector, 1.0);%EOL%    LR = vec4(center_view.xyz + halfWidthTangentVector, 1.0);%EOL%    UL = vec4(LL.xyz + heightVector, 1.0);%EOL%    UR = vec4(LR.xyz + heightVector, 1.0);%EOL%                      %EOL%    // TODO: animate based on wind parameters.%EOL%    float nw = noise[NOISE_SMOOTH];%EOL%    float wind = width*oe_GroundCover_windFactor*nw;%EOL%    UL.x += oe_GroundCover_applyWind(osg_FrameTime*(1+nw), wind, UL.x);%EOL%    UR.x += oe_GroundCover_applyWind(osg_FrameTime*(1-nw), wind, tileUV.t);%EOL%    %EOL%    // Color variation, brightness, and contrast:%EOL%    vec3 color = vec3( noise[NOISE_RANDOM_2] );%EOL%    color = ( ((color - 0.5) * oe_GroundCover_contrast + 0.5) * oe_GroundCover_brightness);%EOL%    %EOL%    // calculates normals:%EOL%    vec3 faceNormalVector = normalize(cross(tangentVector, heightVector));%EOL%%EOL%#ifdef OE_GROUNDCOVER_USE_TOP_BILLBOARDS%EOL%    // if we are looking straight-ish down on the billboard, don't bother with it%EOL%    if (billboard.atlasIndexTop < 0 && %EOL%        abs(dot(normalize(center_view.xyz), faceNormalVector)) < 0.01)%EOL%    {%EOL%        return;%EOL%    }%EOL%#else%EOL%    // if we are looking straight-ish down on the billboard, don't bother with it%EOL%    if (abs(dot(normalize(center_view.xyz), faceNormalVector)) < 0.01)%EOL%    {%EOL%        return;%EOL%    }%EOL%#endif%EOL%%EOL%    float blend = 0.25 + (noise[NOISE_RANDOM_2]*0.25);%EOL%    vec3 Lnormal = mix(-tangentVector, faceNormalVector, blend);%EOL%    vec3 Rnormal = mix( tangentVector, faceNormalVector, blend);%EOL%%EOL%    float billboardAmount = 1.0;%EOL%%EOL%#ifdef OE_GROUNDCOVER_USE_TOP_BILLBOARDS%EOL%    float topDownAmount = 0.0;%EOL%    if (billboard.atlasIndexTop >= 0)%EOL%    {%EOL%        // calculate a [0..1] factor for interpolating from a front billboard view%EOL%        // to a top-down view of the tree (0.0=billboard, 1.0=topdown)%EOL%        topDownAmount = abs(dot(vec3(0, 0, -1), up_view));%EOL%        billboardAmount = 1.0 - oe_GroundCover_fastpow(topDownAmount, 10.0);%EOL%        topDownAmount = clamp(topDownAmount*1.5, 0.0, 1.0);%EOL%    }%EOL%%EOL%    const float billboardThreshold = 0.15;%EOL%%EOL%    if (billboardAmount > billboardThreshold)%EOL%#endif%EOL%    {%EOL%        vp_Color = vec4(color*oe_GroundCover_ao, falloff * billboardAmount);%EOL%%EOL%        gl_Position = LL;%EOL%        oe_GroundCover_texCoord = vec2(0.0, 0.0);%EOL%        vp_Normal = Lnormal;%EOL%        VP_EmitViewVertex();%EOL%%EOL%        gl_Position = LR;%EOL%        oe_GroundCover_texCoord = vec2(1.0, 0.0);%EOL%        vp_Normal = Rnormal;%EOL%        VP_EmitViewVertex();%EOL%%EOL%        vp_Color = vec4(color, falloff * billboardAmount);%EOL%%EOL%        gl_Position = UL;%EOL%        oe_GroundCover_texCoord = vec2(0.0, 1.0);%EOL%        vp_Normal = Lnormal;%EOL%        VP_EmitViewVertex();%EOL%%EOL%        oe_GroundCover_texCoord = vec2(1.0, 1.0);%EOL%        vp_Normal = Rnormal;%EOL%        gl_Position = UR;%EOL%        VP_EmitViewVertex();%EOL%%EOL%        EndPrimitive();%EOL%    }%EOL%%EOL%%EOL%#ifdef OE_GROUNDCOVER_USE_TOP_BILLBOARDS%EOL%    const float topDownThreshold = 0.5;%EOL%%EOL%    if (topDownAmount > topDownThreshold && billboard.atlasIndexTop >= 0)%EOL%    {%EOL%        oe_GroundCover_atlasIndex = float(billboard.atlasIndexTop);%EOL%        // estiblish the local tangent plane:%EOL%        vec3 U = gl_NormalMatrix * vec3(0, 0, 1);%EOL%        vec3 E = cross(U, up_view);%EOL%        vec3 N = cross(up_view, E);%EOL%%EOL%        // now introduce a %QUOTE%random%QUOTE% rotation (using barycentric coords)%EOL%        b = b * 2.0 - 1.0;  // from [0..1] to [-1..1]%EOL%        N = normalize(E*b.x + N * b.y);%EOL%        E = normalize(cross(N, U));%EOL%%EOL%        float k = width * 0.5;%EOL%        vec3 C = center_view.xyz + (heightVector*0.4);%EOL%        LL = vec4(C - E*k - N*k, 1.0);%EOL%        LR = vec4(C + E*k - N*k, 1.0);%EOL%        UL = vec4(C - E*k + N*k, 1.0);%EOL%        UR = vec4(C + E*k + N*k, 1.0);%EOL%%EOL%        vp_Color = vec4(color, (topDownAmount - topDownThreshold)*(topDownAmount / topDownThreshold));%EOL%%EOL%        gl_Position = LL;%EOL%        oe_GroundCover_texCoord = vec2(0.0, 0.0);%EOL%        vp_Normal = (LL.xyz - C);%EOL%        VP_EmitViewVertex();%EOL%%EOL%        gl_Position = LR;%EOL%        oe_GroundCover_texCoord = vec2(1.0, 0.0);%EOL%        vp_Normal = (LR.xyz - C);%EOL%        VP_EmitViewVertex();%EOL%%EOL%        gl_Position = UL;%EOL%        oe_GroundCover_texCoord = vec2(0.0, 1.0);%EOL%        vp_Normal = (UL.xyz - C);%EOL%        VP_EmitViewVertex();%EOL%%EOL%        gl_Position = UR;%EOL%        oe_GroundCover_texCoord = vec2(1.0, 1.0);%EOL%        vp_Normal = (UR.xyz - C);%EOL%        VP_EmitViewVertex();%EOL%%EOL%        EndPrimitive();%EOL%    }%EOL%#endif // OE_GROUNDCOVER_USE_TOP_BILLBOARDS%EOL%    %EOL%#endif // !OE_IS_SHADOW_CAMERA%EOL%}%EOL%%EOL%";

    GroundCover_FS = "GroundCover.FS.glsl";
    _sources[GroundCover_FS] = "#version $GLSL_VERSION_STR%EOL%#pragma vp_name       Land cover billboard texture application%EOL%#pragma vp_entryPoint oe_GroundCover_FS%EOL%#pragma vp_location   fragment_coloring%EOL%%EOL%#pragma import_defines(OE_GROUNDCOVER_COLOR_SAMPLER)%EOL%#pragma import_defines(OE_GROUNDCOVER_COLOR_MATRIX)%EOL%#pragma import_defines(OE_IS_SHADOW_CAMERA)%EOL%#ifdef OE_GROUNDCOVER_COLOR_SAMPLER%EOL%uniform sampler2D OE_GROUNDCOVER_COLOR_SAMPLER ;%EOL%uniform mat4 OE_GROUNDCOVER_COLOR_MATRIX ;%EOL%in vec4 oe_layer_tilec;%EOL%#endif%EOL%%EOL%uniform sampler2DArray oe_GroundCover_billboardTex;%EOL%%EOL%uniform int oe_GroundCover_instancedModel;%EOL%%EOL%uniform float oe_GroundCover_maxAlpha;%EOL%uniform int oe_GroundCover_A2C;%EOL%%EOL%in vec2 oe_GroundCover_texCoord;%EOL%%EOL%flat in float oe_GroundCover_atlasIndex;%EOL%%EOL%void oe_GroundCover_FS(inout vec4 color)%EOL%{%EOL%    if (oe_GroundCover_atlasIndex < 0.0)%EOL%        discard;%EOL%%EOL%    if (oe_GroundCover_instancedModel == 0)%EOL%    {%EOL%        // modulate the texture%EOL%        color *= texture(oe_GroundCover_billboardTex, vec3(oe_GroundCover_texCoord, oe_GroundCover_atlasIndex));%EOL%    %EOL%#ifdef OE_IS_SHADOW_CAMERA%EOL%        if (color.a < oe_GroundCover_maxAlpha)%EOL%        {%EOL%            discard;%EOL%        }%EOL%#else%EOL%        if (oe_GroundCover_A2C == 1)%EOL%        {%EOL%            // https://medium.com/@bgolus/anti-aliased-alpha-test-the-esoteric-alpha-to-coverage-8b177335ae4f%EOL%            // good for distant trees, but bad for top/side url blending - comment out for now%EOL%            //color.a = (color.a - oe_GroundCover_maxAlpha) / max(fwidth(color.a), 0.0001) + 0.5;%EOL%        }%EOL%        else if (color.a < oe_GroundCover_maxAlpha)%EOL%        {%EOL%            discard;%EOL%        }%EOL%#endif%EOL%    }%EOL%    else%EOL%    {%EOL%        color.rgba = vec4(1,.6,.2,1);%EOL%    }%EOL%%EOL%#ifdef OE_GROUNDCOVER_COLOR_SAMPLER%EOL%    const float modulation = 0.75;%EOL%    float mono = (color.r*0.2126 + color.g*0.7152 + color.b*0.0722);%EOL%    vec4 mod_color = texture(OE_GROUNDCOVER_COLOR_SAMPLER, (OE_GROUNDCOVER_COLOR_MATRIX*oe_layer_tilec).st);%EOL%    color.rgb = mix(color.rgb, mod_color.rgb*vec3(mono)*2.0, modulation);%EOL%#endif%EOL%}%EOL%%EOL%";
}
